<!DOCTYPE html>
<html lang="en-US">
  <head>
    

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
  const config = {
    theme: 'neutral',
    startOnLoad:true,
    htmlLabels:true,
  };
  mermaid.initialize(config);
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <link rel="stylesheet" href="/blog/assets/css/main.css">
    <script src="https://kit.fontawesome.com/f9271f6bdd.js" crossorigin="anonymous"></script>
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  </head>

  <body class="font-mono list-disc bg-gray-700">
    <div class="pt-8 bg-gray-700">
      
        <nav class="flex flex-wrap items-center justify-center px-2 py-4 mb-6">
  <div class="titleImagePosition">
    <a href="/blog/" class="!px-0 !py-0">
      <img class="titleImage" src="/blog/assets/img/title.jpeg" alt="author profile image">
    </a>
  </div>
</nav>

      
      
  
    <div id='sidebar' class='fixed py-16 hidden lg:block'></div>
    <div id='burger-sidebar' class='pt-24 pl-4 fixed hidden md:block'></div>
  

  <div class='prose bg-gray-400' id='article'>
    <div id='word-count' class='pt-4 pl-8 fixed'>words: 80</div>
    <div class='text-center'>
      
    </div>
    <div class='md:px-4 md:grid lg:px-72'>
      <h1 class='text-center mt-6 mb-6'>Concurrency</h1>
      <h2 id="introduction">Introduction</h2>

<p>Concurrency is a decoupling strategy that separates the execution of tasks from the timing of their execution. It becomes necessary when there are numerous tasks that need to be completed within a given timeframe. However, concurrency can introduce issues such as different results being returned by the same method simultaneously. To address these problems, principles like Single Responsibility, limiting the scope of data, using copies of data, and ensuring thread independence can be applied. Additionally, employing thread-safe collections, implementing producer-consumer and reader-writer patterns, and handling synchronization through semaphores can help mitigate concurrency-related challenges.</p>

<h2 id="why">Why</h2>

<p>Concurrency is a <strong>decoupling</strong> strategy. It helps us decouple what gets done <strong>from when</strong> it gets done, so we need it if there are too many tasks should be done in a given time.</p>

<h2 id="how">How</h2>

<h3 id="issues">Issues</h3>

<p>Concurrency may cause problems that <strong>same method</strong> return <strong>different results</strong> at the same time and the way to solve the problems is as follow:</p>

<ul>
  <li>Concurrency Defense Principle
    <ul>
      <li>Single Responsibility Principle: Only responsible for a <strong>signle client</strong></li>
      <li>Corollary, Limit the Scope of Data: Only <strong>one service</strong> for updating one scope of data</li>
      <li>Corollary, Use Copies of Data: Multiple services but only <strong>one way</strong> to insert data</li>
      <li>Corollary, Threads Should Be as Independent as Possible: combined with the above strategies, it should be only <strong>one client</strong> changes only <strong>one scope of data</strong> at the same time</li>
    </ul>
  </li>
</ul>

<p>Given the above design principle, we may still facing the following problems:</p>

<ul>
  <li>Thread-Safe Collections: Use the thread-safe collections to avoid updating data based on the wrong old data</li>
  <li>Producer-Consumer: Use this design pattern to solve multiple calculation of threads in a given resources such as memory</li>
</ul>
<div class="mermaid">
  graph LR
    id1((parent_1)) -- push: calculations --&gt; id2[jobs_queue]
    id3((student_1)) -- push: calculations --&gt; id2[jobs_queue]
    id4((...)) -- push: any_other_calculations --&gt; id2[jobs_queue]
  
    id2[jobs_queue] --&gt; id5((machine1))
    id2[jobs_queue] --&gt; id8((machine1))
    id2[jobs_queue] --&gt; id6((machine2))
    id2[jobs_queue] --&gt; id7((...))
</div>

<ul>
  <li>Reader-Writer: Use semaphore to ensure only <strong>one writer</strong> to a data at the same time</li>
</ul>

<p>We will use lots of <code class="language-plaintext highlighter-rouge">synchronized</code> method to solve the problems above, causing following problems:</p>

<ul>
  <li>Client-side: Synchronized on the client side but we may forgot to do so</li>
  <li>Server-side: Synchronized on the server side but subtle problems occur when there are multiple <strong>dependent</strong> variables needs synchronization</li>
  <li><strong>Dining Philosophers</strong>:
    <ul>
      <li>Starvation: Some threads is <strong>prohibited from</strong> proceeding for an excessively long time or forever</li>
      <li>Deadlock: Threads <strong>waiting</strong> for <strong>each other</strong> to finish</li>
      <li>Livelock: Threads trying to do work but finding another “in the way.”</li>
      <li>(TBC) Add a graph of breast touching alley</li>
    </ul>
  </li>
</ul>

<p>Then finally, we have other issues:</p>

<ul>
  <li>Writing Correct Shut-Down Code Is Hard: review the jobs regularly and find out which job often have dining philosophers problem and solve it on the early stage</li>
  <li>Testing Threaded Code
    <ul>
      <li>Treat Spurious Failures as Candidate Threading Issues: When a minor system issue occurs, it is invariably related to threads.</li>
      <li>Get Your Nonthreaded Code Working First: However, let’s first ensure that the code unrelated to threads is implemented correctly.</li>
      <li>Make Your Threaded Code Pluggable: Make the code related to threads easily interchangeable, so that various possibilities can be explored and tested.</li>
      <li>Make Your Threaded Code Tunable: You should make the necessary modifications to your threaded code while ensuring that the system continues to run smoothly.</li>
      <li>Run with More Threads Than Processors: Increase the number of threads compared to processors so that you have a chance to encounter the Dining Philosophers problem early on and find a solution for it.</li>
      <li>Run on Different Platforms: Early deployment of your threads on different platforms allows you to identify bugs and issues ahead of time.</li>
      <li>Instrument Your Code to Try and Force Failures: You can intentionally set waiting times or change the order of thread execution to reproduce a specific combination of events and try to identify and resolve the problem.</li>
    </ul>
  </li>
</ul>

<h3 id="use-case">Use case</h3>

<p>For example, let’s say Faria Kindergarten is organizing a quick reflex competition. The engineers have designed a button that, when pressed, will increase the count by one. It goes as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span>
  <span class="vi">@score</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If parents compete with their children, but the engineers intentionally programmed the same method to be triggered upon pressing the button, it would be as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
  <span class="n">params</span><span class="p">[</span><span class="ss">:class</span><span class="p">].</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">score</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If the competition has become more complex over time, with the addition of a quiz mechanism and the need for complex calculations, let’s assume that the competition now requires the machine to perform a comprehensive computation lasting 5 to 10 seconds. In this case, if concurrency is preferred, the update would be as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
  <span class="no">CheckService</span><span class="p">.</span><span class="nf">perform_sync</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">CheckService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="n">correct?</span>
      <span class="n">params</span><span class="p">[</span><span class="ss">:class</span><span class="p">].</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="o">...</span> <span class="c1"># 5 ~ 10 seconds</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>After some time, the boss noticed that the children’s scores were consistently higher than those of the parents, and wanted the engineers to investigate the reason behind it. At this point, we encounter the first issue, and the principle to solve it is the Single Responsibility Principle. Since all the methods are written in the same code, debugging, experimentation, and code changes will affect the other party. Therefore, it would be best to have one service for each client. The solution is as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update_parent</span>
  <span class="o">...</span>
  <span class="no">CheckParentService</span><span class="p">.</span><span class="nf">perform_sync</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">update_student</span>
  <span class="o">...</span>
  <span class="no">CheckStudentService</span><span class="p">.</span><span class="nf">perform_sync</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
<span class="k">end</span>
<span class="o">...</span>
</code></pre></div></div>

<p>In the ongoing investigation, it was discovered that the parents were answering too quickly, resulting in the service retrieving an outdated score during the score update process. As a result, the service would insert multiple scores with the same value. This is the second issue we encountered. To solve it, we can apply two principles: <strong>Limit the Scope of Data and Use Copies of Data</strong>.</p>

<p><a id="limit_the_scope_of_data_example" href="#limit_the_scope_of_data">Limit the Scope of Data</a> does synchronization in the service. We need to synchronize the number of counter before we update the value. In ruby, we use <code class="language-plaintext highlighter-rouge">Mutex</code> to do the trick as follow:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
    <span class="vi">@jobs_mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@counter</span> <span class="o">=</span> <span class="no">Parent</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">synchronize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="vi">@jobs_mutex</span><span class="p">.</span><span class="nf">synchronize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="n">correct?</span>
      <span class="n">synchronize</span> <span class="k">do</span> <span class="c1"># 要存進去的時候同步一次</span>
        <span class="vi">@counter</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="o">...</span> <span class="c1"># 5 ~ 10 seconds</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><a id="use_copies_of_data_example" href="#use_copies_of_data">Use Copies of Data</a> does not share data in the service but collect all the calculated information and do a single update as follow:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Parent</span>
  <span class="nb">attr_reader</span> <span class="ss">:counter</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
    <span class="vi">@counter</span> <span class="o">=</span> <span class="no">Parent</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span>
    <span class="vi">@corrects</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="n">correct?</span>
      <span class="vi">@corrects</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Scheduled task to update the counter</span>
<span class="n">every</span> <span class="ss">:day</span><span class="p">,</span> <span class="ss">at: </span><span class="s1">'12:00 PM'</span> <span class="k">do</span>
  <span class="n">sum</span> <span class="o">=</span> <span class="vi">@corrects</span><span class="p">.</span><span class="nf">sum</span>
  <span class="vi">@counter</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Even with this design in place, we may still encounter race condition. Apart from the Queue, all other data structures are susceptible to race conditions because they are not Thread-Safe Collections. In Ruby, the solution is to use the concurrent-ruby gem to create thread-safe data structures or to synchronize data using Mutex, as mentioned earlier.</p>

<p>Later on, the engineers managed to resolve these issues. However, after some time, the parents’ scores were still lower than those of the students, and occasionally, the situation would suddenly reverse. After conducting thorough research, the engineers discovered that many of the parents’ jobs were not completed by midnight each day. As a result, the scores fluctuated, being sometimes high and sometimes low. This gave rise to the next issue, <a id="producer_consumer_example" href="#producer_consumer">Producer-Consumer</a>. We can design a queue where calculations are only inserted when there are available machine resources. This way, we can avoid losing any jobs. Therefore, if the boss is keen on having the calculations completed by midnight every day, they would need to invest more money in additional machines to increase the number of consumers. This would ensure that there are enough resources to handle the workload, and the issue can be resolved. We typically use Sidekiq to achieve this functionality.</p>

<p>After resolving the above issues, the boss wants to see real-time score updates, which necessitates synchronization within the Service. At this point, we encounter the next issue, the “Reader-Writer problem.” There might be a race condition when two writers attempt to write to the same data concurrently. To address this, our solution is to introduce a semaphore that indicates whether there is currently a writer updating that particular data. Here is an example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@jobs_mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@can_write</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="n">correct?</span> <span class="o">&amp;&amp;</span> <span class="vi">@can_write</span> <span class="c1"># 寫之前先 check can_write</span>
      <span class="n">synchronize</span> <span class="k">do</span>
        <span class="vi">@counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="vi">@can_write</span> <span class="o">=</span> <span class="kp">false</span> <span class="c1"># 寫之前先把 can_write 關掉</span>
        <span class="n">save!</span>
        <span class="vi">@can_write</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>After resolving the above situations, we encounter another issue arising from the minor problems caused by the use of synchronize. Suppose the boss wants to make the competition more exciting by changing it to see who can answer 100 questions correctly. Later, a parent gets angry, claiming to have answered 101 questions. The boss asks the engineers to investigate the issue, and they discover that the problem lies with the synchronize method in this service. The original logic implemented by the engineers was to stop awarding points after answering 100 questions correctly, as shown below:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@counter</span> <span class="o">=</span> <span class="no">Parent</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span>
    <span class="vi">@accomplished</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="vi">@accomplished</span> <span class="o">=</span> <span class="kp">true</span> <span class="k">if</span> <span class="vi">@counter</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="c1"># key logic</span>
    <span class="k">if</span> <span class="n">correct?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="vi">@accomplished</span>
      <span class="n">synchronize</span> <span class="k">do</span>
        <span class="vi">@accomplished</span> <span class="c1"># get @accomplished from other threads</span>
        <span class="vi">@counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">save!</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In fact, this issue is understandable because the calculation for each question takes 5-10 seconds. Therefore, it is possible that the parent has actually answered 100 questions but is still in the calculation process, resulting in the situation where the parent has answered one extra question. To address this, changes are required on both the client-side and server-side.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update_parent</span>
  <span class="k">if</span> <span class="vi">@accomplished</span>
    <span class="k">return</span> <span class="s1">'mission accomplished'</span>
  <span class="k">else</span>
    <span class="no">CheckParentService</span><span class="p">.</span><span class="nf">perform_sync</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@counter</span> <span class="o">=</span> <span class="no">Parent</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@counter</span> <span class="o">&gt;=</span> <span class="mi">100</span>
      <span class="vi">@accomplished</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="k">elsif</span> <span class="n">correct?</span> <span class="o">&amp;&amp;</span> <span class="vi">@counter</span> <span class="o">&lt;</span> <span class="mi">100</span>
      <span class="n">synchronize</span> <span class="k">do</span>
        <span class="vi">@counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">save!</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It is indeed noticeable that the issue mentioned above arises from the need to synchronize two variables that are interrelated. The clean code author suggests that the best approach is to design the logic in a way that <strong>minimizes the interdependence of variables requiring synchronization</strong>.</p>

<p>Later, the boss felt that the parents’ scores were too high, so the difficulty of the questions was adjusted, requiring more temporary storage for calculations. The engineers noticed that a certain type of challenging job was never being processed by the computer. This was because the job required at least 5MB of temporary storage, but it was always being preempted by other jobs before it could acquire the necessary 5MB of storage. This situation is known as the “Starvation” problem in the context of the Dining Philosophers problem.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
    <span class="vi">@stop</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="n">synchronize</span> <span class="k">do</span>
      <span class="vi">@stop</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="n">synchronize</span> <span class="k">do</span>
      <span class="vi">@stop</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckStudentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="o">!</span><span class="vi">@stop</span> <span class="c1"># 如果沒有來自 ParentService 叫停的信號再做下去</span>
      <span class="o">...</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Later, the boss came up with the idea of implementing a mechanism where both parents and students could answer questions together. Each question required a certain amount of computation time. Unfortunately, due to poor design, this implementation resulted in a deadlock.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@student_correct</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@parent_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="c1"># waiting</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckStudentService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@parent_correct</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@student_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="c1"># waiting</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In the above design, the situation you described could lead to a scenario where both @parent_correct and @student_correct are nil. Since both parties need to wait for the other to be marked as correct before proceeding with further calculations, neither of them would progress, resulting in no computations being performed.</p>

<p>To address this issue, a possible solution is to use <code class="language-plaintext highlighter-rouge">semaphores</code>. When a job arrives at the CheckParentService, it can first check the signal from the CheckStudentService. If it determines that the student is still performing calculations, the parent job can proceed with its own computations independently.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
    <span class="n">synchronize</span> <span class="k">do</span>
      <span class="vi">@student_calculating</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@student_correct</span> <span class="o">||</span> <span class="vi">@student_calculating</span>
      <span class="c1"># do the calculation</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@parent_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="c1"># waiting</span>
    <span class="k">end</span>
  <span class="k">end</span>
  
  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="vi">@parent_calculating</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="o">...</span>
</code></pre></div></div>

<p>We may use another solution where one party waits for the other to finish calculations before proceeding, may seem like a potential solution. However, in practice, it can lead to a situation called “livelock,” where both parties continuously yield to each other without making progress. As a result, this is not a good solution.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@student_calculating</span>
      <span class="vi">@parent_calculating</span> <span class="o">=</span> <span class="kp">false</span>
      <span class="c1"># waiting</span>
    <span class="k">else</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@parent_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="vi">@parent_calculating</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="o">...</span> <span class="c1"># lots of calculation</span>
    <span class="vi">@parent_calculating</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckStudentService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@parent_calculating</span>
      <span class="vi">@student_calculating</span> <span class="o">=</span> <span class="kp">false</span>
      <span class="c1"># waiting</span>
    <span class="k">else</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@student_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="vi">@student_calculating</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="o">...</span> <span class="c1"># lots of calculation</span>
    <span class="vi">@student_calculating</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="what">What</h2>

<h2 id="reference">Reference</h2>

<p>clean code by Robert</p>

    </div>
  </div>

  <footer class="relative px-4 pt-4 pb-4">
    <!-- footer msg -->
  <div class="flex flex-wrap items-center justify-center">
    <br>
  </div>
</footer>


      <button
        type="button"
        data-mdb-ripple="true"
        data-mdb-ripple-color="light"
        class="scrollTopBtn"
        id="btn-back-to-top"
      >
        <svg aria-hidden="true" focusable="false" data-prefix="fas" class="w-4 h-4" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"></path></svg>
      </button>
    </div>
  </body>

  <script>
    /* Function for getting the current year in the footer */
    (function () {
      if (document.getElementById("get-current-year")) {
        document.getElementById(
          "get-current-year"
        ).innerHTML = new Date().getFullYear();
      }
    })();
    /* Function for opening navbar on mobile */
    function toggleNavbar(collapseID) {
        document.getElementById(collapseID).classList.toggle("hidden");
        document.getElementById(collapseID).classList.toggle("block");
      }
    /* Function for dropdowns */
    function openDropdown(event, dropdownID) {
      let element = event.target;
      while (element.nodeName !== "A") {
        element = element.parentNode;
      }
      document.getElementById(dropdownID).classList.toggle("hidden");
      document.getElementById(dropdownID).classList.toggle("block");
    }

    // Get the button
    let myButton = document.getElementById("btn-back-to-top");
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function () {
      scrollFunction();
    };
    function scrollFunction() {
      if (
        document.body.scrollTop > 20 ||
        document.documentElement.scrollTop > 20
      ) {
        myButton.style.display = "block";
      } else {
        myButton.style.display = "none";
      }
    }
    // When the user clicks on the button, scroll to the top of the document
    myButton.addEventListener("click", backToTop);
    function backToTop() {
      document.body.scrollTop = 0;
      document.documentElement.scrollTop = 0;
    }
  </script>

  <script type="text/javascript" src="/blog/assets/javascript/bundle.js" charset="utf-8"></script>
</html>
