<!DOCTYPE html>
<html lang="en-US">
  <head>
    

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js"></script>

<script src='/implement_p5.js'></script>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
  const config = {
    theme: 'neutral',
    startOnLoad:true,
    htmlLabels:true,
  };
  mermaid.initialize(config);
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <link rel="stylesheet" href="/blog/assets/css/main.css">
    <script src="https://kit.fontawesome.com/f9271f6bdd.js" crossorigin="anonymous"></script>
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  </head>

  <body class="font-mono list-disc bg-gray-700">
    <div class="pt-8 bg-gray-700">
      
        <nav class="flex flex-wrap items-center justify-center px-2 py-4 mb-6">
  <div class="titleImagePosition">
    <a href="/blog/" class="!px-0 !py-0">
      <img class="titleImage" src="/blog/assets/img/title.jpeg" alt="author profile image">
    </a>
  </div>
  <div class="flex">
    <div class="container px-4 mx-auto flex flex-wrap items-center justify-center">
      <div class="absolute right-16 flex md:block" id="navbar">
        <div class="flex flex-col md:flex-row mr-auto w-full">
          <!-- dynamic menu based on navigation info in _config.yml -->
          
             <!-- don't show current page in menu -->
              <a class="text-sm text-gray-500 hover:text-gray-900 px-3 py-2 mx-auto uppercase"
                href="/blog/about">
                About Me
              </a>
            
          
        </div>
      </div>
    </div>
  </div>
</nav>

      
      
  <div id='sidebar' class='fixed py-16'></div>
  <div id='burger-sidebar' class='pt-24 pl-4 fixed'></div>

<div class='p-16 prose bg-gray-400' id='article'>
  <div class='text-center'>
    
  </div>
  <div class='md:px-4 md:grid lg:px-72'>
    <h1 class='text-center mt-6 mb-6'>ch13 concurrency</h1>
    <h2 id="introduction--why">Introduction &amp; why?</h2>

<p>Concurrency is a <strong>decoupling</strong> strategy. It helps us decouple what gets done <strong>from when</strong> it gets done, so we need it if there are too many tasks should be done in a given time; however it causes problems that <strong>same method</strong> return <strong>different results</strong> at the same time and the way to solve the problems is as follow:</p>

<ul>
  <li>Concurrency Defense Principle
    <ul>
      <li><a id="single_responsiblitiy_principle" href="#single_responsiblitiy_principle_example">Single Responsibility Principle</a>: only responsible for a <strong>signle client</strong></li>
      <li>Corollary, <a id="limit_the_scope_of_data" href="#limit_the_scope_of_data_example">Limit the Scope of Data</a>: only <strong>one service</strong> for updating one scope of data</li>
      <li>Corollary, <a id="use_copies_of_data" href="#use_copies_of_data_example">Use Copies of Data</a>: mulitple services but only <strong>one way</strong> to insert data</li>
      <li>Corollary, Threads Should Be as Independent as Possible: combined with the above strategies, it should be only <strong>one client</strong> changes only <strong>one scope of data</strong> at the same time</li>
    </ul>
  </li>
</ul>

<p>Given the above design principle, we may still facing the following problems:</p>

<ul>
  <li><a id="thread_safe_collections" href="#thread_safe_collections_example">Thread-Safe Collections</a>: use the thread-safe collections to avoid updaing data based on the wrong old data</li>
  <li><a id="producer_consumer" href="#producer_consumer_example">Producer-Consumer</a>: use this design pattern to solve multiple calculation of threads in a given resources such as memory</li>
</ul>
<div class="mermaid">
graph LR
  id1((parent_1)) -- push: calculations --&gt; id2[jobs_queue]
  id3((student_1)) -- push: calculations --&gt; id2[jobs_queue]
  id4((...)) -- push: any_other_calculations --&gt; id2[jobs_queue]

  id2[jobs_queue] --&gt; id5((machine1))
  id2[jobs_queue] --&gt; id8((machine1))
  id2[jobs_queue] --&gt; id6((machine2))
  id2[jobs_queue] --&gt; id7((...))
</div>

<ul>
  <li><a id="reader_writer" href="#reader_writer_example">Reader-Writer</a>: use semaphore to ensure only <strong>one writer</strong> to a data at the same time</li>
</ul>

<p>We will use <a id="lots_of_synchronized" href="#lots_of_synchronized_example">lots of <code class="language-plaintext highlighter-rouge">synchronized</code></a> method to solve the problems above, causing following problems:</p>

<ul>
  <li>client-side: synchronized on the client side but we may forgot to do so</li>
  <li>server-side: synchronized on the server side but subtle problems occur when there are multiple <strong>dependent</strong> variables needs synchronization</li>
  <li><strong>Dining Philosophers</strong>:
    <ul>
      <li><a id="starvation" href="#starvation_example">Starvation</a>: Some threads is <strong>prohibited from</strong> proceeding for an excessively long time or forever</li>
      <li><a id="deadlock" href="#deadlock_example">Deadlock</a>: Threads <strong>waiting</strong> for <strong>each other</strong> to finish</li>
      <li><a id="livelock" href="#livelock_example">Livelock</a>: Threads trying to do work but finding another “in the way.”</li>
    </ul>
  </li>
</ul>

<h4 id="dining-philosophers-concepts-摸乳巷">Dining Philosophers concepts (摸乳巷)</h4>

<ul>
  <li>三角形代表瘦子 (兩個三角形相遇都側身的話兩個都能通過)</li>
  <li>圓形代表胖子 (胖子就是側身也過不了，大家都要讓他)</li>
</ul>

<div id="concept" class="h-screen justify-center items-center">
  <div id="concept toggle" class=""></div>
  <div id="concept canvas" class="border"></div>
</div>

<script>
  const filename = 'dining_philosophers.png'
  const imagePath = '/assets/img/' + filename
  const conceptDiv = document.getElementById('concept');
  const conceptWidth = conceptDiv.offsetWidth;
  let eraseEnable = false;
  let img;
  let photoGraph;

  function setup() {
    setupImage ()
    setupButton ()
    setupCanvas ()
    setupGraphics ()
  }

  function draw() {
    image(img, 0, 0, conceptWidth, 400);
    image(graphic, 0, 0)
  }

  function mouseDragged() {
    if (!eraseEnable) {
      graphic.fill('black');
      graphic.noStroke();
      graphic.ellipse(mouseX, mouseY, 5, 5);
    } else {
      graphic.fill('white');
      graphic.noStroke();
      graphic.ellipse(mouseX, mouseY, 10, 10);
    }
  }

  function keyTyped() {
    if (key === 's') {
      saveCanvas(filename);
    }
  }

  function setupImage () {
    try {
      img = loadImage(imagePath);
    }
    catch {
      img = createImage(conceptWidth, 400)
    }
  }

  function setupButton () {
    toggleButton = createButton('erase');
    toggleButton.parent('concept toggle');
    toggleButton.addClass("border rounded px-4");
    toggleButton.mouseClicked(ButtonClicked)
  }

  function setupCanvas () {
    const concept = createCanvas(conceptWidth, 400);
    concept.parent('concept canvas');
  }

  function setupGraphics () {
    graphic = createGraphics(conceptWidth, 400);
  }

  function ButtonClicked () {
    toggleStyle()
    toggleErase()
  }

  function toggleErase() {
    if (eraseEnable) {
      noErase();
      eraseEnable = false;
    }
    else {
      erase();
      eraseEnable = true;
    }
  }

  function toggleStyle() {
    toggleButton.toggleClass("bg-indigo-100");
    toggleButton.toggleClass("border");
  }
</script>

<p>Then finally, we have <a id="other_issue">following issue</a>:</p>

<ul>
  <li>Writing Correct Shut-Down Code Is Hard: review the jobs regularly and find out which job often have dining philosophers problem and solve it on the early stage</li>
  <li>Testing Threaded Code
    <ul>
      <li>Treat Spurious Failures as Candidate Threading Issues: 一發生小小的系統障礙 -&gt; 一定跟 thread 有關</li>
      <li>Get Your Nonthreaded Code Working First: 但我們還是先把跟 thread 無關的 code 做好</li>
      <li>Make Your Threaded Code Pluggable: 讓 thread 的 code 很好拔插，這樣就可以做出各種可能來檢測</li>
      <li>Make Your Threaded Code Tunable: 你要讓你的 threaded code 做了改動，系統還是跑得很順</li>
      <li>Run with More Threads Than Processors: 讓 threads 的數量多於 processors，這樣你就有機會提前遇到 dining philosophers 問題，並解決</li>
      <li>Run on Different Platforms: 提早讓你的 threads 在不同平台上跑動，這樣可以提早發現 bug</li>
      <li>Instrument Your Code to Try and Force Failures: 有些 bug 的發生來自一個特定的排列組合，你可以刻意設定等待時間或是交換 thread 的先後順序，嘗試reproduce 這個特定的排列組合，以解決問題。</li>
    </ul>
  </li>
</ul>

<h2 id="how--what">How? &amp; What?</h2>

<p>舉例來講，faria 幼稚園舉辦手速比賽，工程師設計了按鈕，點下去就會加一，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span>
  <span class="vi">@score</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果家長跟小朋友比賽，但工程師都刻意 POST 同一個 method，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
  <span class="n">params</span><span class="p">[</span><span class="ss">:class</span><span class="p">].</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">score</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上面的方法看起來沒什麼問題，結果比賽辦得太好了，所以這個比賽隨著日子變得越來越複雜，多了答題機制，還需要複雜的運算。假設比賽後來變成需要機器做一個 5~10 秒的綜合運算，這樣用 concurrency 比較好，則此時 update 變成</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
  <span class="no">CheckService</span><span class="p">.</span><span class="nf">perform_sync</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">CheckService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="n">correct?</span>
      <span class="n">params</span><span class="p">[</span><span class="ss">:class</span><span class="p">].</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="o">...</span> <span class="c1"># 5 ~ 10 seconds</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>過了一陣子，老闆覺得小朋友的分數老是超過家長，要工程師研究一下為什麼，這時候我們遇到第一個 issue，解決原則是 <a id="single_responsiblitiy_principle_example" href="#single_responsiblitiy_principle">Single Responsibility Principle</a>，因為方法都是寫同一個，要 debug，要做實驗要改動 code，都會影響到另外一方，所以最好就是一個 service for 一個 client，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update_parent</span>
  <span class="o">...</span>
  <span class="no">CheckParentService</span><span class="p">.</span><span class="nf">perform_sync</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">update_student</span>
  <span class="o">...</span>
  <span class="no">CheckStudentService</span><span class="p">.</span><span class="nf">perform_sync</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="o">...</span>
<span class="k">end</span>
<span class="o">...</span>
</code></pre></div></div>

<p>那在持續追查的情況下，發現家長回答的速度太快，結果 service 在 update score 的時候，都拿到比較舊的 score，在 service 運算完後 insert 進一大堆分數都一樣的值。這就是我們遇到的第二個 issue，解決原則有兩個，Limit the Scope of Data 與 Use Copies of Data。</p>

<p><a id="limit_the_scope_of_data_example" href="#limit_the_scope_of_data">Limit the Scope of Data</a> 是在 Service 裡進行同步，我們要在 update 值之前，先同步一次 counter 的數據，在 ruby 裡我們是使用 <code class="language-plaintext highlighter-rouge">Mutex</code>，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
    <span class="vi">@jobs_mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@counter</span> <span class="o">=</span> <span class="no">Parent</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">synchronize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="vi">@jobs_mutex</span><span class="p">.</span><span class="nf">synchronize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="n">correct?</span>
      <span class="n">synchronize</span> <span class="k">do</span> <span class="c1"># 要存進去的時候同步一次</span>
        <span class="vi">@counter</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="o">...</span> <span class="c1"># 5 ~ 10 seconds</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><a id="use_copies_of_data_example" href="#use_copies_of_data">Use Copies of Data</a> 則是一開始我們就不要共享資料，然後搜集好所有 correct 後再一次用個 single thread update，方法如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Parent</span>
  <span class="nb">attr_reader</span> <span class="ss">:counter</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
    <span class="vi">@counter</span> <span class="o">=</span> <span class="no">Parent</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span>
    <span class="vi">@corrects</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="n">correct?</span>
      <span class="vi">@corrects</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">every</span> <span class="ss">:day</span><span class="p">,</span> <span class="ss">at: </span><span class="mi">12</span>
  <span class="vi">@counter</span><span class="p">.</span><span class="nf">sum</span>
<span class="k">end</span>
</code></pre></div></div>

<p>就算我們如此設計了，還是可能遇到問題，第一個問題是我們沒有使用 <a id="thread_safe_collections_example" href="#thread_safe_collections">Thread-Safe Collections</a>。除了 Queue 之外，所有資料結構都可能有 race condition，在 ruby 的解決方法是使用 <code class="language-plaintext highlighter-rouge">concurrent-ruby</code> gem 來創建資料結構，或是使用如上介紹的 <code class="language-plaintext highlighter-rouge">Mutex</code> 來 synchronize 資料。</p>

<p>後來工程師都排除這些問題了，但過了一陣子家長的分數還是又低於學生，但有時候又會突然變回來，工程師們經過嚴密的研究，發現有很多家長的 Job 在每天凌晨 12 點的時候根本沒計算完，所以分數時高時低，這帶來下一個 issue，<a id="producer_consumer_example" href="#producer_consumer">Producer-Consumer</a>。我們可以設計一個 queue，機器有剩餘的 resource 時才將 calculations insert 進去，這樣就不會有 Job 丟失的狀況了。所以如果老闆很希望每天凌晨 12 點計算好，那他就要投資更多機器的錢，讓 Consumer 變多，這樣就不會有問題了，我們通常用 <code class="language-plaintext highlighter-rouge">sidekiq</code> 來達成。</p>

<p>在解決以上問題後，老闆希望看到分數的即時播報，所以一定要在 Service 裡進行同步，這時候我們會遇到下一個 issue，<a id="reader_writer_example" href="#reader_writer">Reader-Writer problem</a>。因為同時間可能會有兩個 writer 會寫入同一格資料的 race condition，我們的解決方法是加入 <code class="language-plaintext highlighter-rouge">semaphore</code> 告知說先在這格沒有 writer 在寫喔，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@jobs_mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@can_write</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="n">correct?</span> <span class="o">&amp;&amp;</span> <span class="vi">@can_write</span> <span class="c1"># 寫之前先 check can_write</span>
      <span class="n">synchronize</span> <span class="k">do</span>
        <span class="vi">@counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="vi">@can_write</span> <span class="o">=</span> <span class="kp">false</span> <span class="c1"># 寫之前先把 can_write 關掉</span>
        <span class="n">save!</span>
        <span class="vi">@can_write</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上面的狀況都排除後，就會開始發生<a id="lots_of_synchronized_example" href="#lots_of_synchronized">因為 <code class="language-plaintext highlighter-rouge">synchronize</code> 產生的小問題</a>。假設老闆覺得這場比賽要刺激一點，就改成比誰先答對 100 題，事後有個家長很生氣，說自己做了 101 題，老闆請工程師了解一下狀況，後來發現是這個 service 的 <code class="language-plaintext highlighter-rouge">synchronize</code> 出了問題。工程師原先的邏輯是，答對 100 題後，就不再加分了，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@counter</span> <span class="o">=</span> <span class="no">Parent</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span>
    <span class="vi">@accomplished</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="vi">@accomplished</span> <span class="o">=</span> <span class="kp">true</span> <span class="k">if</span> <span class="vi">@counter</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="c1"># key logic</span>
    <span class="k">if</span> <span class="n">correct?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="vi">@accomplished</span>
      <span class="n">synchronize</span> <span class="k">do</span>
        <span class="vi">@accomplished</span> <span class="c1"># get @accomplished from other threads</span>
        <span class="vi">@counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">save!</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>其實這個問題是無可厚非的，因為一題的計算本來就是 5~10 秒，所以最後本來就有可能有其實已經答對 100 題，但還在計算所以家長多做 1 題的狀況。要改動他就需要同時對 client side 與 server side 進行改動，讓 server-side 還是只需要同步 <code class="language-plaintext highlighter-rouge">@counter</code>，然後讓題目即時在 client-side 停止，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update_parent</span>
  <span class="k">if</span> <span class="vi">@accomplished</span>
    <span class="k">return</span> <span class="s1">'mission accomplished'</span>
  <span class="k">else</span>
    <span class="no">CheckParentService</span><span class="p">.</span><span class="nf">perform_sync</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@counter</span> <span class="o">=</span> <span class="no">Parent</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">counter</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@counter</span> <span class="o">&gt;=</span> <span class="mi">100</span>
      <span class="vi">@accomplished</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="k">elsif</span> <span class="n">correct?</span> <span class="o">&amp;&amp;</span> <span class="vi">@counter</span> <span class="o">&lt;</span> <span class="mi">100</span>
      <span class="n">synchronize</span> <span class="k">do</span>
        <span class="vi">@counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">save!</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>大家應該會發現引發上面問題的原因是，有兩個 variables 要被同步，而且這兩個變數還相互有關聯。作者說最好的方式就是設計好的邏輯，<strong>限縮越少有關連的變數同步越好</strong>。</p>

<p>後來老闆覺得家長分數太高，所以就調整了題目難度，需要更多暫存做計算。工程師們發現這一類比較難的 Job 總是不會被計算機計算，因為計算時它需要至少 5MB 的暫存，但總是釋放還不到 5MB 的暫存時，就被其他 Job 佔走了，這就是 Dining Philosophers 中的 <a id="starvation_example" href="#starvation">Starvation</a> 問題，解決方法是使用 <code class="language-plaintext highlighter-rouge">semaphore</code>。當此 job 出現時，用 <code class="language-plaintext highlighter-rouge">Mutex</code> 發出訊號給其他 Job，讓他們先不要再 <code class="language-plaintext highlighter-rouge">perform</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
    <span class="vi">@stop</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="n">synchronize</span> <span class="k">do</span>
      <span class="vi">@stop</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="n">synchronize</span> <span class="k">do</span>
      <span class="vi">@stop</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckStudentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="o">!</span><span class="vi">@stop</span> <span class="c1"># 如果沒有來自 ParentService 叫停的信號再做下去</span>
      <span class="o">...</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>後來老闆又覺得可以來一個家長跟學生共同答題的機制，兩個問題都需要一定的計算時間，結果沒設計好，產生 <a id="deadlock_example" href="#deadlock">deadlock</a>，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@student_correct</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@parent_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="c1"># waiting</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckStudentService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@parent_correct</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@student_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="c1"># waiting</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>結果有可能 <code class="language-plaintext highlighter-rouge">@parent_correct</code> 跟 <code class="language-plaintext highlighter-rouge">@student_correct</code> 都是 <code class="language-plaintext highlighter-rouge">nil</code>，但因為雙方都要等對方 correct，才會進行後續計算，結果就是都沒有計算。解決辦法一樣是使用 semaphore。當 Job 到 <code class="language-plaintext highlighter-rouge">CheckParentService</code> 時，可以先檢查 <code class="language-plaintext highlighter-rouge">CheckStudentService</code> 的訊號，發現 student 還在計算，那我就先算下去了，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="o">...</span>
    <span class="n">synchronize</span> <span class="k">do</span>
      <span class="vi">@student_calculating</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@student_correct</span> <span class="o">||</span> <span class="vi">@student_calculating</span>
      <span class="c1"># do the calculation</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@parent_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="c1"># waiting</span>
    <span class="k">end</span>
  <span class="k">end</span>
  
  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="vi">@parent_calculating</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="o">...</span>
</code></pre></div></div>

<p>我們可能會想說用另外一個方法解決以上問題，就是你如果在計算，那我就先等你算，啊然後我自己先不算，但實際上會產生 <a id="livelock_example" href="#livelock">livelock</a>，雙方一直在讓對方，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CheckParentService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@student_calculating</span>
      <span class="vi">@parent_calculating</span> <span class="o">=</span> <span class="kp">false</span>
      <span class="c1"># waiting</span>
    <span class="k">else</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@parent_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="vi">@parent_calculating</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="o">...</span> <span class="c1"># lots of calculation</span>
    <span class="vi">@parent_calculating</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CheckStudentService</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">perform</span>
    <span class="k">if</span> <span class="vi">@parent_calculating</span>
      <span class="vi">@student_calculating</span> <span class="o">=</span> <span class="kp">false</span>
      <span class="c1"># waiting</span>
    <span class="k">else</span>
      <span class="k">if</span> <span class="n">correct?</span>
        <span class="vi">@student_correct</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">correct?</span>
    <span class="vi">@student_calculating</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="o">...</span> <span class="c1"># lots of calculation</span>
    <span class="vi">@student_calculating</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p><a href="#other_issue">其他議題</a></p>

<h2 id="reference">Reference</h2>

<p>clean code by Robert</p>

  </div>
</div>

<footer class="relative px-4 pt-4 pb-4">
    <!-- footer msg -->
  <div class="flex flex-wrap items-center justify-center">
    <br>
  </div>
</footer>

      <button
        type="button"
        data-mdb-ripple="true"
        data-mdb-ripple-color="light"
        class="scrollTopBtn"
        id="btn-back-to-top"
      >
        <svg aria-hidden="true" focusable="false" data-prefix="fas" class="w-4 h-4" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"></path></svg>
      </button>
    </div>
  </body>

  <script>
    /* Function for getting the current year in the footer */
    (function () {
      if (document.getElementById("get-current-year")) {
        document.getElementById(
          "get-current-year"
        ).innerHTML = new Date().getFullYear();
      }
    })();
    /* Function for opening navbar on mobile */
    function toggleNavbar(collapseID) {
        document.getElementById(collapseID).classList.toggle("hidden");
        document.getElementById(collapseID).classList.toggle("block");
      }
    /* Function for dropdowns */
    function openDropdown(event, dropdownID) {
      let element = event.target;
      while (element.nodeName !== "A") {
        element = element.parentNode;
      }
      document.getElementById(dropdownID).classList.toggle("hidden");
      document.getElementById(dropdownID).classList.toggle("block");
    }

    // Get the button
    let myButton = document.getElementById("btn-back-to-top");
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function () {
      scrollFunction();
    };
    function scrollFunction() {
      if (
        document.body.scrollTop > 20 ||
        document.documentElement.scrollTop > 20
      ) {
        myButton.style.display = "block";
      } else {
        myButton.style.display = "none";
      }
    }
    // When the user clicks on the button, scroll to the top of the document
    myButton.addEventListener("click", backToTop);
    function backToTop() {
      document.body.scrollTop = 0;
      document.documentElement.scrollTop = 0;
    }
  </script>

  <script type="text/javascript" src="/blog/assets/javascript/bundle.js" charset="utf-8"></script>
</html>
