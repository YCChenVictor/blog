---
layout: post
title:
description: ''
date: '2023-03-19'
categories: DSA
note:
mathjax:
mermaid: true
p5:
threeJS:
anchor:
publish: true
---

## Introduction

* This article describes the concept of graph, non-linear data structure that consists of a collection of vertices (also known as nodes) connected by edges.
* Vertices represent the objects or entities being modeled
* Edges represent the relationships or connections between those objects. Edges can be directed or undirected, and can have weights or costs associated with them to represent the strength or importance of the relationship between vertices
* Represented using various data structures, such as adjacency matrices, adjacency lists, and edge lists
* Algorithms
  * traversal algorithms
    * depth-first search
    * breadth-first search
  * shortest path algorithms
    * Dijkstra's algorithm
    * Bellman-Ford algorithm
  * minimum spanning tree algorithms
    * Prim's algorithm
    * Kruskal's algorithm

## Why?

To pass coding interview

## How?

### Visualization

<div class="mermaid">
flowchart TD
    id1((1)) --> id2((2))
    id4((4)) --> id2((2))
    id4((4)) --> id3((3))
    id1((1)) --> id4((4))
    id3((3)) --> id1((1))
    id2((2)) --> id2((2))
</div>

### terminology

* vertices: the nodes with naming, 1, 2, 3, 4
* edges: the lines connect the vertices
* self loop: the edge from a vertex to itself

### code example

```javascript
class Graph {
  constructor() {
    this.vertices = new Map();
  }

  addVertex(vertex) {
    this.vertices.set(vertex, []);
  }

  addEdge(vertex1, vertex2) {
    this.vertices.get(vertex1).push(vertex2);
    this.vertices.get(vertex2).push(vertex1);
  }

  getNeighbors(vertex) {
    return this.vertices.get(vertex);
  }

  depthFirstSearch(startVertex, visited = new Set()) {
    visited.add(startVertex);
    this.getNeighbors(startVertex).forEach(vertex => {
      if(!visited.has(vertex)) {
        this.depthFirstSearch(vertex)
      }
    })
  }
}
```

* DFS (depth first search)
  * Application: Find paths between two vertices, detecting cycles in a graph, and determining whether a graph is bipartite
  * Solution: Visits each node exactly once and records the path it takes to reach each node. The algorithm can be implemented recursively or iteratively using a stack.
  * Concept: Follow a path as far as possible before **backtracking and exploring** other paths. This means that DFS explores the deepest possible path in the graph before backtracking, hence the name "depth-first"
  * Intuition: Have a look at this [video](https://www.youtube.com/watch?v=7fujbpJ0LB4)

```javascript
const graph = {
  'A': ['B', 'C'],
  'B': ['D', 'E'],
  'C': ['F'],
  'D': [],
  'E': ['F'],
  'F': []
};

const visited = new Set();

function dfs(node) {
  console.log(node)
  if (!visited.has(node)) {
    visited.add(node);
    graph[node].forEach((neighbor) => {
      dfs(neighbor);
    });
  }
}

dfs('A');

console.log(visited);
```

A -> B -> D -> E -> F -> C -> F

### time complexity

* Adding a vertex: O(1) (constant time)
* Adding an edge: O(1) (constant time)
* Removing a vertex: O(V + E) (linear time, where V is the number of vertices and E is the number of edges)
* Removing an edge: O(1) (constant time)
* Finding a vertex: O(V) (linear time)
* Finding an edge: O(E) (linear time)
* Depth-first search: O(V + E) (linear time)
* Breadth-first search: O(V + E) (linear time)
* Shortest path (Dijkstra's algorithm): O((V + E) * log V) (where V is the number of vertices and E is the number of edges)
* Minimum spanning tree (Prim's algorithm): O((V + E) * log V) (where V is the number of vertices and E is the number of edges)

## What?

### Maze

* Try to find the shortest path in maze with DFS
* Represent maze as a graph, each cell is a node and the neighboring cells are connected by edges
* Use a depth-first search algorithm to explore all possible paths from the starting cell to the exit cell. We can mark each cell as visited as we explore the maze and keep track of the shortest path we've found so far. Once we reach the exit cell, we compare the length of the path we've found to the shortest path so far and update it if the new path is shorter.
* This approach can be optimized using techniques such as backtracking and memoization to avoid exploring paths that cannot lead to the shortest path.

## Reference

[Graph Data Structure in Javascript](https://www.tutorialspoint.com/Graph-Data-Structure-in-Javascript#:~:text=A%20graph%20is%20a%20pictorial,the%20vertices%20are%20called%20edges.)

[10 Graph Algorithms Visually Explained](https://towardsdatascience.com/10-graph-algorithms-visually-explained-e57faa1336f3)
