---
layout: post
title:
description: ''
date: '2023-03-19'
categories: DSA
note:
mathjax:
mermaid: true
p5:
threeJS:
anchor:
publish: true
---

## Introduction

* This article describes the concept of graph, non-linear data structure that consists of a collection of vertices (also known as nodes) connected by edges.
* Vertices represent the objects or entities being modeled
* Edges represent the relationships or connections between those objects. Edges can be directed or undirected, and can have weights or costs associated with them to represent the strength or importance of the relationship between vertices
* Represented using various data structures, such as adjacency matrices, adjacency lists, and edge lists
* Algorithms
  * traversal algorithms
    * depth-first search
    * breadth-first search
  * shortest path algorithms
    * Dijkstra's algorithm
    * Bellman-Ford algorithm
  * minimum spanning tree algorithms
    * Prim's algorithm
    * Kruskal's algorithm

## Why?

To pass coding interview

## How?

### terminology

<div class="mermaid">
flowchart TD
    id1((1)) --> id2((2))
    id4((4)) --> id2((2))
    id4((4)) --> id3((3))
    id1((1)) --> id4((4))
    id3((3)) --> id1((1))
    id2((2)) --> id2((2))
</div>

* vertices: the nodes with naming, 1, 2, 3, 4
* edges: the lines connect the vertices
* self loop: the edge from a vertex to itself

```javascript
class Graph {
  constructor() {
    this.vertices = new Map();
  }

  addVertex(vertex) {
    this.vertices.set(vertex, []);
  }

  addEdge(vertex1, vertex2) {
    this.vertices.get(vertex1).push(vertex2);
    this.vertices.get(vertex2).push(vertex1);
  }

  getNeighbors(vertex) {
    return this.vertices.get(vertex);
  }
}
```

### time complexity

* Adding a vertex: O(1) (constant time)
* Adding an edge: O(1) (constant time)
* Removing a vertex: O(V + E) (linear time, where V is the number of vertices and E is the number of edges)
* Removing an edge: O(1) (constant time)
* Finding a vertex: O(V) (linear time)
* Finding an edge: O(E) (linear time)
* Depth-first search: O(V + E) (linear time)
* Breadth-first search: O(V + E) (linear time)
* Shortest path (Dijkstra's algorithm): O((V + E) * log V) (where V is the number of vertices and E is the number of edges)
* Minimum spanning tree (Prim's algorithm): O((V + E) * log V) (where V is the number of vertices and E is the number of edges)

## What?

give an example

[test]({{site.baseurl}}/test/2021/06/14/xxx.html)

<img src="{{site.baseurl}}/assets/img/xxx.png" alt="">

## Reference

[Graph Data Structure in Javascript](https://www.tutorialspoint.com/Graph-Data-Structure-in-Javascript#:~:text=A%20graph%20is%20a%20pictorial,the%20vertices%20are%20called%20edges.)

[10 Graph Algorithms Visually Explained](https://towardsdatascience.com/10-graph-algorithms-visually-explained-e57faa1336f3)
