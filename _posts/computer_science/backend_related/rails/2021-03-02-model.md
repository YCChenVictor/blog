---
layout: post
title:
note:
date: '2021-03-02T04:18:25.484Z'
categories: rails
publish: true
---

## Introduction

* A model is a Ruby class that is used to represent data. Additionally, models can interact with the application's database through a feature of Rails called [Active Record]({{site.baseurl}}/rails/2021/06/10/active-record.html)
* An object refers to an instance of a class, which represents a single record in a database table.

In this article, I am not going to research how rails code methods in model, so in how section will be basic coding examples for me to understand the concepts. Please refer to [Active Record]({{site.baseurl}}/rails/2021/06/10/active-record.html) to see how rails code the default model methods.

## Why

With model, we can use consistent commands to communicate with all type of databases such as MySQL, Postgresql, …etc.

## How

### Create One

Define a Ruby class that inherits from the ActiveRecord::Base class. This class will represent a table in your database, and the properties of the class will map to columns in the table. Here is an example:

```ruby
class User < ActiveRecord::Base
end
```

In this example, we have defined a `User` class that inherits from `ActiveRecord::Base`. This class will represent a table called users in our database (convention), and it will have properties that map to columns in the users table.

Then we can interact with database with this model:

* Creating a new record

```ruby
user = User.new(name: 'John', email: 'john@example.com')
user.save
```

In this example, we create a new User record by creating a new instance of the User class and setting its properties. We then call the save method on the instance to save it to the database.

* Updating a record

```ruby
user = User.find_by(name: 'John')
user.email = 'new_email@example.com'
user.save
```

In this example, we find an existing User record by querying the database for a record with a name of 'John'. We then update the email property of the record and save the changes to the database.

* Querying records

```ruby
users = User.where(age: 18..35)
```

In this example, we use the where method on the User class to query the database for all User records with an age between 18 and 35. The result of the query is a collection of User instances that match the criteria.

### relation

* belongs_to: Used to define a one-to-many relationship between two tables
* has_many: Used to define a one-to-many relationship between two tables
* has_one: Used to define a one-to-one relationship between two tables
* example: We have a User model, a Profile model, and a Post model. Each user has one profile, and each user can have many posts. Each post belongs to a user.

To define these associations,

```ruby
class User < ApplicationRecord
  has_one :profile
  has_many :posts
end

class Profile < ApplicationRecord
  belongs_to :user
end

class Post < ApplicationRecord
  belongs_to :user
  has_one :profile, through: :user # because user has one profile and also has many posts
end
```

This tells Rails that each User has one Profile, and that each User can have many Posts. It also tells Rails that each Profile belongs to a User, and that each Post belongs to a User. By default, Rails assumes that the posts table has a foreign key called user_id that references the id column of the users table.

Access related data:

```ruby
@user = User.find(params[:id])
@profile = @user.profile

@user = User.find(params[:id])
@posts = @user.posts

@post = Post.find(params[:id])
@user = @post.user

@post = Post.find(params[:id])
@profile = @post.profile
```

### validation

* Validations help ensure that the data is accurate, consistent, and secure.
* Built-in validation helpers
  * presence: Validates that the specified attributes are not empty.
  * uniqueness: Validates that the specified attributes are unique.
  * length: Validates the length of the specified attributes.
  * format: Validates that the specified attributes match a specified regular expression pattern.
  * numericality: Validates that the specified attributes are numeric.
* code example:

```ruby
class User < ApplicationRecord
  validates :name, presence: true, length: { minimum: 2 }
  validates :email, presence: true, uniqueness: true, format: { with: /\A[^@\s]+@[^@\s]+\z/ }
  validates :age, numericality: { only_integer: true, greater_than: 0, less_than: 150 }
end
```

In this example, we have a User model with three attributes: name, email, and age. We're using validations to ensure that the name attribute is present and has a minimum length of 2, the email attribute is present, unique, and matches a valid email format, and the age attribute is an integer between 0 and 150.

If any of these validations fail, Rails will prevent the model from being saved to the database and add an error message to the corresponding attribute. You can then use these error messages to display validation errors to the user or perform other actions based on whether the validations passed or failed.

It's important to note that validations only apply when creating or updating records through Active Record. If you're updating records through SQL, validations won't be checked. Additionally, if you're performing bulk updates, such as with update_all, validations won't be checked either.

### callback

before_save: Used to define a callback that is executed before the model is saved to the database.

after_save: Used to define a callback that is executed after the model is saved to the database.

before_create: Used to define a callback that is executed before a new record is created in the database.

after_create: Used to define a callback that is executed after a new record is created in the database.

before_destroy: Used to define a callback that is executed before a record is deleted from the database.

after_destroy: Used to define a callback that is executed after a record is deleted from the database.

## What

### real world example

Sure! Here's an example of a real-world Rails model that includes relationships between models, validations, and callbacks.

Let's say we have an e-commerce application with three models: Product, Order, and LineItem. A Product can have many LineItems, and a LineItem belongs to a Product and an Order. An Order can have many LineItems.

ruby
Copy code
class Product < ApplicationRecord
  has_many :line_items, dependent: :destroy
  validates :name, :price, presence: true
end

class Order < ApplicationRecord
  has_many :line_items, dependent: :destroy
  validates :name, :email, presence: true
  before_create :set_order_status
  before_save :update_subtotal

  def subtotal
    line_items.map(&:total_price).sum
  end

  private

  def set_order_status
    self.status = 'pending'
  end

  def update_subtotal
    self[:subtotal] = subtotal
  end
end

class LineItem < ApplicationRecord
  belongs_to :product
  belongs_to :order, optional: true
  validates :product_id, presence: true
  validates :quantity, numericality: { only_integer: true, greater_than: 0 }

  def total_price
    product.price * quantity
  end
end
In the Product model, we define a has_many association with LineItem, specifying that if a Product is destroyed, all its associated LineItems should be destroyed too. We also add a validation that requires name and price to be present.

In the Order model, we define a has_many association with LineItem, specifying that if an Order is destroyed, all its associated LineItems should be destroyed too. We also add two validations that require name and email to be present, and two callbacks that set the initial status of the Order to "pending" and update the subtotal of the Order whenever a LineItem is saved.

In the LineItem model, we define a belongs_to association with Product and Order. We also add two validations that require the product_id to be present and the quantity to be greater than zero, as well as a method that calculates the total price of the line item.

With these relationships, validations, and callbacks in place, we can easily create, update, and delete products, orders, and line items in our e-commerce application.

#### example of scope

To get all candidates with `age > 18`, in controller,

```ruby
class CandidatesController < ApplicationController  
  def index  
    @candidate_18 = Candidate.where("age > 18")  
  end
end
```

;however, if there is going to have more conditions, the code will be hard to maintain. As a result, we can use scope in model to organize the business logic as follow:

```ruby
class Candidate < ApplicationRecord  
  scope :above_18, -> { where(age > 18) }
end
```

Then the code in controller can be rewritten as

```ruby
class CandidatesController < ApplicationController
  def index  
    @candidate_18 = Candidate.above_18  
  end
end
```

* self-defined method: TBC

The key difference: if the condition of scope cannot find data, it returns all; but if the condition of self-defined method cannot find data, it returns nil. As a result, we can use Model.scope(a).scope(b).... with no worries.

default_scope is the default scope that all queries runs first.

### Example of Interact with database

* ORM

#### ORM

ORM helps user to communicate with database with the concept of object.

* Create
* Read
* Update
* Delete

To create a candidate

```ruby
user = Candidate.new(name: "aaa", age: 19)  
user.save
```

means in SQL,

```SQL
TBC
```

To read all users,

```ruby
User.all
```

means in SQL,

```SQL
SELECT * FROM users;
```

To find all table names

```ruby
ActiveRecord::Base.connection.tables
```

means in SQL,

```SQL
TBC
```

To update the candidate’s name with id = 1,

```ruby
candidate = Candidate.find_by(id: 1)  
candidate.name = "hahaha"  
candidate.save

# SQL
```

or

```ruby
candidate.update(name: "hahahaha", age: 20)

# SQL
```

To delete candidate with id = 1,

```ruby
Candidate.destroy(1)
```

means in SQL

```SQL
TBC
```

Notice! `delete` will call the SQL delete directly, so no callbacks during deleting process. By ignoring callback and relation, `delete` is faster than `destroy`.

#### Migration

TBC

* add
* delete
* migrate
* rollback

To add model, `Article` with columns: title, content, is_online

```bash
rails g model Article title content:text is_online:boolean
```

* To remove invoke while generating, `--no-helper --no-assets --no-controller-specs --no-view-specs` or

```bash
# application.rb
config.generators.assets = false
config.generators.helper = false
```

Then in db/migrate, timestamp_create_articles.rb:

```ruby
class CreateArticles < ActiveRecord::Migration[6.1]  
  def change  
    create_table :articles do |t|  
      t.string :title  
      t.text :content  
      t.boolean :is_online  
        
      t.timestamps  
    end  
  end  
end
```

* timestamp for recording `:created_at, :updated_at`

To delete migration files,

```bash
rails d migration MigrationName
```

Notice! please do it only before `db:migrate`

To migrate,

Execute the migration
```
rails db:migrate
```

To rollback,

If we want to cancel migrations; for example, we know that we want to rollback 3 steps of migrations
```
$ rails db:rollback STEP=3
```
However, the Rollback method is not recommended. We should use another migration to modify database to what we want; for example, if we want to **add a column** to an existed table, we can add another generate migration

#### Schema

If we want to know which migration ever be executed

```ruby
$ rails db:migrate:status
```

#### What migration can achieve?

create_table
change_table
drop_table
add_column
change_column
rename_column
remove_column
add_index
remove_index


(1) rename a table
```
$ rails g migration change_[old_table_name]_to_[new_table_name]
```
and migration file:
```
def change
  rename_table :[old_table_name], :[new_table_name]
end
```
(2) add a column
```
$ rails generate migration add_email_to_users
```
and migration file:
```
class AddEmailToUsers < ActiveRecord::Migration[5.0]
  def change
    add_column :users, :email, :string
  end
end
```
(3) changing column
```

```
(4) dropping table
```
$ rails generate migration drop_tablename
```
and the migration file:
```
def change
  drop_table :table_name
end
```
(5) removing column

#### Change vs Up & Down

####

## Reference

[為你自己學 Ruby on Rails 高見龍]("https://railsbook.tw/")

[change vs up & down](https://rubyinrails.com/2014/05/14/rails-migration-change-vs-up-down-methods/)

[Getting Started with Rails](https://guides.rubyonrails.org/getting_started.html)
