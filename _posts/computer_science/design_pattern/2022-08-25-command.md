---
layout: post
title:
description: ''
date: '2022-08-25'
categories: design-pattern
note:
mathjax:
mermaid: true
p5:
threeJS:
anchor:
publish: true
---

## Introduction

<<<<<<< HEAD
quick explanation

## Why?

This article describes the concept of command pattern. The basic UML:

<div class="mermaid">
graph LR
  id1(Invoker) --#1--> id2(browser 1)
  id1(user 1) --#2--> id2(browser 1)

  id3(user 2) --#3--> id4(browser 2)
  id3(user 2) --#4--> id4(browser 2)

  id2(browser 1) --request from #1--> id5(data processing)
  id2(browser 1) --request from #2--> id5(data processing)
  id4(browser 2) --request from #3--> id5(data processing)
  id4(browser 2) --request from #4--> id5(data processing)

  id5(data processing) --query from #1--> id6(database)
  id5(data processing) --query from #2--> id6(database)
  id5(data processing) --query from #3--> id6(database)
  id5(data processing) --query from #4--> id6(database)
</div>

## Why?

With command pattern, we can wrap operations into stand-alone objects in which we can

* pass the operations as parameters
* arrange the order of operations
* reverse the operations

## How?

focus on the mechanim

## What?

### ruby example

A robot performs a serial movements to dance: right leg, left hand, head, butt and we can write a script as follow:

```ruby
class Robot
  def initialize
  end

  def move_right_leg
    puts 'move right leg'
  end

  def move_left_leg
    puts 'move left leg'
  end

  def move_head
    puts 'move head'
  end

  def move_butt
    puts 'move butt'
  end

  # ... other movements
end

robot = Robot.new

robot.move_right_leg
robot.move_left_leg
robot.move_head
robot.move_butt
```

With command pattern, we can achieve properties:

* change remote control (invoker)
* queue series commands (not every language supports metaprogramming)
* can reverse command (unexecute) (恢復上一動)

```ruby
class Robot # unchanged
  def initialize
  end

  def move_right_leg
    puts 'move right leg'
  end

  def move_left_leg
    puts 'move left leg'
  end

  def move_head
    puts 'move head'
  end

  def undo_right_leg
    puts 'undo right leg'
  end

  def undo_left_leg
    puts 'undo left leg'
  end

  def undo_head
    puts 'undo head'
  end

  # ... other movements
end

class Command
  def execute
    raise NotImplementedError, "#{self.class} has not implemented method '#{__method__}'"
  end

  def unexecute
    raise NotImplementedError, "#{self.class} has not implemented method '#{__method__}'"
  end
end

class CustomCommand < Command
  def initialize(receiver, commands)
    @receiver = receiver
    @commands = commands
  end

  def execute
    @commands.each do |command|
      case command
      when 'move_right_leg'
        @receiver.move_right_leg
      when 'move_left_leg'
        @receiver.move_left_leg
      when 'move_head'
        @receiver.move_head
      when 'move_butt'
        @receiver.move_butt
      end
    end
  end

  def unexecute
    @commands.reverse_each do |command|
      case command
      when 'move_right_leg'
        @receiver.undo_right_leg
      when 'move_left_leg'
        @receiver.undo_left_leg
      when 'move_head'
        @receiver.undo_head
      when 'move_butt'
        @receiver.undo_butt
      end
    end
  end
end

class HeadCommand
  def initialize(receiver)
    @receiver = receiver
  end

  def execute
    @receiver.move_head
  end

  def unexecute
    @receiver.undo_head
  end
end

class Invoker # can be attached to any remote control
  def initialize
    @history = []
  end

  def on_press_custom_button=(commands) # you can change custom button to any other button
    @on_press_custom_button = commands
  end

  def on_press_head_button=(command) # you can change custom button to any other button
    @on_press_head_button = command
  end

  def execute_custom_command
    @on_press_custom_button.execute if @on_press_custom_button.is_a? Command
    @history.push @on_press_custom_button
  end

  def execute_head_command
    @on_press_head_button.execute if @on_press_head_button.is_a? Command
    @history.push @on_press_head_button
  end

  def undo
    puts @history
    command = @history.pop
    if !command.nil?
      command.unexecute
    end
  end
end
```

Usage

```ruby
invoker = Invoker.new
receiver = Robot.new
invoker.on_press_custom_button = CustomCommand.new(receiver, ['move_right_leg', 'move_left_leg'])
invoker.on_press_head_button = HeadCommand.new(receiver)

invoker.execute_custom_command
# results
# move right leg
# move left leg
invoker.undo
# results
# undo left leg
# undo right leg

invoker.execute_custom_command
invoker.execute_head_command
invoker.undo
invoker.undo
```

## Note

command pattern deals with problems needing lots of commands; for example, to have a dish with spicy, no raw meats, ... there wouldd be lots of commands to tell the chef but with command pattern, it will organize these command and do it step by step (or remove duplicate commands) to finish the dish

最適合應用在有一系列 commands，而這些 commands 你需要紀錄 history 來 rollback，而且你會封裝這些指令，也就是說，你執行他的時候，你並不知道底層跑了什麼東西，例如：鍵盤，其實任何幫助製造出產品的工具都是

## Reference

[Command Pattern – Design Patterns (ep 7)](https://www.youtube.com/watch?v=9qA5kw8dcSU&list=PLrhzvIcii6GNjpARdnO4ueTUAVR9eMBpc&index=7)

[Command](https://refactoring.guru/design-patterns/command)
