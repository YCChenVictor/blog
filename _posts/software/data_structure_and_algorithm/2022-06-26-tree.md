---
layout: post
title: tree
description: ''
date: '2022-06-26'
categories: DSA
note: traversal 真的需要再多一點 elaborate, 之後再把畫圖的工具做更好一點
mathjax:
mermaid: true
p5: true
threeJS:
anchor:
publish: true
---

## Introduction

* A tree is composed of nodes.
* Each tree has a root node.
* Each node has zero or more child nodes.
* The data stored in each node has any datatype.
* Three type of traversals: inorder, preorder, postorder

### types of tree

* general tree: each node has 0 to many child node
  <div class="mermaid">
    graph TD
      id1((A)) --> id2((B))
      id1((A)) --> id3((C))
      id1((A)) --> id4((D))
      id1((A)) --> id5((E))
    
      id2((B)) --> id6((F))
      id3((C)) --> id7((G))
      id3((C)) --> id8((H))
      id5((E)) --> id9((I))
    
      id8((H)) --> id10((J))
  </div>
* binary tree: each node has at most 2 child modes
  <div class="mermaid">
    graph TD
      id1((1)) --> id2((7))
      id1((1)) --> id3((9))
    
      id2((7)) --> id4((2))
      id2((7)) --> id5((6))
      id3((9)) --> STOP1[ ]
      id3((9)) --> id6((9))
    
      id5((6)) --> id7((5))
      id5((6)) --> id8((11))
    
      id6((9)) --> id9((5))
      id6((9)) --> STOP2[ ]
  </div>
* balanced tree
* unbalanced tree
* complete binary tee
* full binary tree
* perfect binary tree

### types of traversal

Given a tree as follow:

<div class="mermaid">
  graph TD
    id1((1)) --> id2((7))
    id1((1)) --> id3((9))
  
    id2((7)) --> id4((2))
    id2((7)) --> id5((6))
    id3((9)) --> STOP1[ ]
    id3((9)) --> id6((9))
  
    id5((6)) --> id7((5))
    id5((6)) --> id8((11))
  
    id6((9)) --> id9((5))
    id6((9)) --> STOP2[ ]
</div>

There are three actions we can do in current node

* visit (return the value of current node)
* left (traverse to the left node)
* right (traverse to the right)

After each traverse, redo it from begin

* inorder traversals (L > V > R): 2 -> 7 -> 5 -> 6 -> 11 -> 1 -> 9 -> 5 -> 9
* preorder traversals (V > L > R): 1 -> 7 -> 2 -> 6 -> 5 -> 11 -> 9 -> 9 -> 5
* postorder traversals (L > R > V): 2 -> 5 -> 11 -> 6 -> 7 -> 5 -> 9 -> 9 -> 1

Tips: for example, in inorder traversal, the tree with root 7 > root 1 > tree with root 9, so it will traverse the nodes of tree with root 7 first then root 1 then tree with root 9.

### essential structure

Tree:

```javascript
class Tree {
  constructor() {
    this.root = new TreeNode(key, value);
  }

  traversal(node = this.root) {
    
  }

  insert() { // we can only insert node as leaf
    
  }

  remove() {

  }

  find() {

  }
}

class TreeNode {
  constructor(key, value = key, parent = null) {
    this.key = key;
    this.value = value;
    this.parent = parent;
    this.children = [];
  }

  get isLeaf() {
    return this.children === 0;
  }

  get hasChildren() {
    return !this.isLeaf;
  }
}
```

## Why?

To pass coding interview

## How?

### Binary Tree

* diagram (the number of left node is not necessary smaller than the right node)
  ```bash
          5
        /   \
       3     8
      / \   / \
     2   4 7   9
  ```
* code example
  ```javascript
  Node = require('./node.js')
  
  class BinaryTree {
    constructor() {
      this.root = null;
    }
  
    addNode(value) { // will use recursive
      if (this.root === null) {
        this.root = new Node(value)
      } else {
        this.insertNode(this.root, new Node(value))
      }
    }
  
    inorderTraversal() { // L > V > R
      // traverse(5) -> [traverse(3), push(5), traverse(8)] -> [2] -> [traverse(2), push(3), traverse(4)], push(5), [traverse(7), push(8), traverse(9)]
      const result = [];
  
      function traverse(node) {
        if (node) {
          traverse(node.left);
          result.push(node.value);
          traverse(node.right);
        }
      }
  
      traverse(this.root);
      return result;
    }
  
    preorderTraversal() { // V > L > R
      // traverse(5) -> [push(5), traverse(3), traverse(8)] -> [push(5), push(3), traverse(2), traverse(4), push(8), traverse(7), traverse(9)]
      const result = [];
  
      function traverse(node) {
        if (node) {
          result.push(node.value)
          traverse(node.left);
          traverse(node.right);
        }
      }
  
      traverse(this.root);
      return result
    }
  
    postorderTraversal() { // L > R > V
      const result = [];
  
      function traverse(node) {
        if (node) {
          traverse(node.left);
          traverse(node.right);
          result.push(node.value)
        }
      }
  
      traverse(this.root);
      return result
    }
    
    levelorderTraversal() {
      const queue = [this.root]
      const result = []
  
      if (!this.root) {
        return
      }
  
      while (queue.length > 0) {
        const node = queue.shift()
        result.push(node.value)
  
        if (node.left !== null) {
          queue.push(node.left)
        }
        if (node.right !== null) {
          queue.push(node.right)
        }
      }
  
      return result
    }
  
    insertNode(parentNode, newNode) {
      // there is no specific insertion method for binary tree
    }
  }
  
  module.exports = BinaryTree
  ```

### Binary Search Tree

TODO: inherit from BinaryTree

A Binary Search Tree (BST) is a data structure consisting of nodes with a value and two pointers to other nodes, known as the left and right child nodes. The values are organized to facilitate efficient search and insertion operations. To search or insert a value, we move left or right depending on whether the value is less or greater than the current node's value. The efficiency of a BST depends on the balance of the tree, with a well-balanced tree providing faster operations than a poorly balanced one.

* diagram
  ```bash
          5
        /   \
       3     8
      / \   / \
     2   4 7   9
  ```
* code example
  ```javascript
  Node = require('./node.js')
  
  class BinarySearchTree {
    constructor() {
      this.root = null;
    }
  
    addNode(value) { // will use recursive
      if (this.root === null) {
        this.root = new Node(value)
      } else {
        this.insertNode(this.root, new Node(value))
      }
    }
  
    search(value) {
      return this.searchNode(this.root, value);
    }
  
    inorderTraversal() { // L > V > R
      // traverse(5) -> [traverse(3), push(5), traverse(8)] -> [2] -> [traverse(2), push(3), traverse(4)], push(5), [traverse(7), push(8), traverse(9)]
      const result = [];
  
      function traverse(node) {
        if (node) {
          traverse(node.left);
          result.push(node.value);
          traverse(node.right);
        }
      }
  
      traverse(this.root);
      return result;
    }
  
    preorderTraversal() { // V > L > R
      // traverse(5) -> [push(5), traverse(3), traverse(8)] -> [push(5), push(3), traverse(2), traverse(4), push(8), traverse(7), traverse(9)]
      const result = [];
  
      function traverse(node) {
        if (node) {
          result.push(node.value)
          traverse(node.left);
          traverse(node.right);
        }
      }
  
      traverse(this.root);
      return result
    }
  
    postorderTraversal() { // L > R > V
      const result = [];
  
      function traverse(node) {
        if (node) {
          traverse(node.left);
          traverse(node.right);
          result.push(node.value)
        }
      }
  
      traverse(this.root);
      return result
    }
    
    levelorderTraversal() {
      const queue = [this.root]
      const result = []
  
      if (!this.root) {
        return
      }
  
      while (queue.length > 0) {
        const node = queue.shift()
        result.push(node.value)
  
        if (node.left !== null) {
          queue.push(node.left)
        }
        if (node.right !== null) {
          queue.push(node.right)
        }
      }
  
      return result
    }
  
    insertNode(parentNode, newNode) {
      if(newNode.value < parentNode.value){
        if(parentNode.left === null) {
          parentNode.left = newNode;
        } else {
          this.insertNode(parentNode.left, newNode);
        }
      } else {
        if(parentNode.right === null) {
          parentNode.right = newNode;
        } else {
          this.insertNode(parentNode.right, newNode);
        };
      };
    }
  
    searchNode(node, value) {
      if (node === null) {
        return null;
      } else if (value < node.value) {
        return this.searchNode(node.left, value);
      } else if (value > node.value) {
        return this.searchNode(node.right, value);
      } else {
        return node;
      }
    }
  }
  
  module.exports = BinaryTree
  ```
* Time complexity of CRUD
  * create
    * create a tree: O(n)
      * When creating a tree, each node needs to be created and added to the appropriate location in the tree. To create a node, the algorithm needs to allocate memory for the node and set its value and pointers to its children (if any). This takes a constant amount of time per node. Therefore, creating n nodes in the tree takes O(n) time.
    * create a node: O(1)
      * When creating a new node in a tree, the algorithm needs to allocate memory for the node and set its value and pointers to its children (if any). These operations take a constant amount of time, independent of the size of the tree.
      * Inserting a new node into a binary tree requires finding the correct position for the new node in the tree. In the worst case, this involves traversing the height of the tree, which has a time complexity of O(log n) for a balanced binary tree and O(n) for an unbalanced binary tree.
        * O(log n) for a balanced binary tree
        * O(n) for an unbalanced binary tree
  * read: O(n)
    * Pre-order traversal visits each node in the tree in the order root, left subtree, right subtree. The time complexity of pre-order traversal is O(n), where n is the number of nodes in the tree.
    * In-order traversal visits each node in the tree in the order left subtree, root, right subtree. The time complexity of in-order traversal is also O(n), where n is the number of nodes in the tree.
    * Post-order traversal visits each node in the tree in the order left subtree, right subtree, root. The time complexity of post-order traversal is also O(n), where n is the number of nodes in the tree.
    * Level-order traversal visits each node in the tree by level, starting at the root and moving down to each level. The time complexity of level-order traversal is also O(n), where n is the number of nodes in the tree.
  * update: O(1)
    * Updating a node in a binary tree involves finding the node to be updated and then modifying its value. This can be done in O(1) time once the node has been found by traversal methods (O(n)).
  * delete: O(log n) to O(n)
    * Deleting a node from a binary tree requires finding the node to be deleted and then rearranging the tree to maintain its properties. In the worst case, this also involves traversing the height of the tree, which has a time complexity of O(log n) for a balanced binary tree and O(n) for an unbalanced binary tree.
* spec
  ```javascript
  const BinaryTree = require('../examples/binary_tree.js');
  
  describe('BinaryTree', () => {
  //     10
  //    /  \
  //   5    15
  //  / \   / \
  // 3   7 12  17
    let testTree;
    beforeEach(() => {
      testTree = new BinaryTree();
      testTree.addNode(10);
      testTree.addNode(5);
      testTree.addNode(15);
      testTree.addNode(3);
      testTree.addNode(7);
      testTree.addNode(12);
      testTree.addNode(17);
    });
  
    test('#init', () => {
      expect(testTree.root.value).toBe(10)
      expect(testTree.root.left.value).toBe(5)
      expect(testTree.root.left.left.value).toBe(3)
      expect(testTree.root.left.right.value).toBe(7)
      expect(testTree.root.right.value).toBe(15)
      expect(testTree.root.right.left.value).toBe(12)
      expect(testTree.root.right.right.value).toBe(17)
    })
  
    test('#search', () => {
      expect(testTree.search(10)).toEqual({
        value: 10,
        left: {
          value: 5,
          left: {
            value: 3,
            left: null,
            right: null
          },
          right: {
            value: 7,
            left: null,
            right: null
          }
        },
        right: {
          value: 15,
          left: {
            value: 12,
            left: null,
            right: null
          },
          right: {
            value: 17,
            left: null,
            right: null
          }
        }
      })
    })
  
    test('#inorderTraversal', () => { // L > V > R
      expect(testTree.inorderTraversal()).toEqual([3, 5, 7, 10, 12, 15, 17])
    })
  
    test('#preorderTraversal', () => { // V > L > R
      expect(testTree.preorderTraversal()).toEqual([10, 5, 3, 7, 15, 12, 17])
    })
  
    test('#postorderTraversal', () => { // L > R > V
      expect(testTree.postorderTraversal()).toEqual([3, 7, 5, 12, 17, 15, 10])
    })
  
    test('#levelorderTraversal', () => {
      expect(testTree.levelorderTraversal()).toEqual([10, 5, 15, 3, 7, 12, 17])
    })
  });
  ```

## What?

### real world example

A real world example of implementing a decision tree

```javascript
class DecisionTreeNode {
  constructor(question, yesNode, noNode) {
    this.question = question;
    this.yesNode = yesNode;
    this.noNode = noNode;
  }

  ask() {
    console.log(this.question);
    let answer = prompt("Enter yes or no:");
    if (answer === "yes") {
      if (this.yesNode instanceof DecisionTreeNode) {
        return this.yesNode.ask();
      } else {
        console.log(this.yesNode);
      }
    } else if (answer === "no") {
      if (this.noNode instanceof DecisionTreeNode) {
        return this.noNode.ask();
      } else {
        console.log(this.noNode);
      }
    } else {
      console.log("Invalid input. Please enter yes or no.");
      return this.ask();
    }
  }
}

let root = new DecisionTreeNode(
  "Is it a mammal?",
  new DecisionTreeNode(
    "Does it have fur?",
    new DecisionTreeNode("Is it a cat?", "It's a cat!"),
    new DecisionTreeNode("Is it a whale?", "It's a whale!")
  ),
  new DecisionTreeNode(
    "Does it have feathers?",
    new DecisionTreeNode("Is it a bird?", "It's a bird!"),
    new DecisionTreeNode("Is it a snake?", "It's a snake!")
  )
);

root.ask();
```

Each node has a question, a yesNode branch and a noNode branch. The ask() method of the node prompts the user to answer the question and then follows the appropriate branch based on the answer. If the branch is another DecisionTreeNode, it recursively calls the ask() method on that node. If the branch is a leaf node, it simply returns the corresponding result.

### Height of Binary Tree

Given a binary tree, return the height; for example

* QA
  * example 1
  ```
  Input:
       1
      /  \
     2    3
  Output: 2
  ```
  * example 2
  ```
  Input:
    2
     \
      1
     /
   3
  Output: 3
  ```
* code example
  ```javascript
  function maxDepth(node) {
    if(node == null) {
      return 0
    }
  
    lDepth = maxDepth(node.left)
    rDepth = maxDepth(node.right)
  
    if(lDepth > rDepth) {
      return lDepth + 1
    } else {
      return rDepth + 1
    }
  }
  
  module.exports = maxDepth
  ```
* spec
  ```javascript
  const Node = require('../examples/binary_tree_node.js')
  const maxDepth = require('../examples/max_depth.js')
  
  describe('MaxDepth', () => {
    let tree
  
    describe('example 1', () => {
      // Input:
      //    1
      //   /  \
      //  2    3
      // Output: 2
      beforeEach(async () => {
        tree = new Node(1)
        tree.left = new Node(2)
        tree.right = new Node(3)
      })
    
      test('#', () => {  
        expect(maxDepth(tree)).toEqual(2)
      })
    })
    
    describe('example 2', () => {
      // Input:
      //   2
      //    \
      //     1
      //    /
      //  3
      // Output: 3
      beforeEach(async () => {
        tree = new Node(2)
        tree.right = new Node(1)
        tree.right.left = new Node(3)
      })
  
      test('#', () => {
        expect(maxDepth(tree)).toEqual(3)
      })
    })
  })
  ```

Determine if two trees are identical
Mirror tree
Symmetric Tree
Diameter of tree
Checked for Balanced tree
Children Sum Parent
Check for BST
Array to BST
Largest value in each level of binary tree
Maximum GCD of siblings of a binary tree
Zigzag Tree Traversal
Inorder Successor in BST
Kth Largest Element in a BST

## Reference

cracking the coding interview

[JavaScript Data Structures - Tree](https://www.30secondsofcode.org/articles/s/js-data-structures-tree)

[What's the purpose of an asterisk (*) in ES6 generator functions](https://stackoverflow.com/questions/27778105/whats-the-purpose-of-an-asterisk-in-es6-generator-functions)

[Tree Traversals (Inorder, Preorder and Postorder)](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)

[Binary Tree: Traversal(尋訪)](http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#pre)

[Global and instance mode](https://github.com/processing/p5.js/wiki/Global-and-instance-mode)

[Difference between Binary Tree and Binary Search Tree](https://www.geeksforgeeks.org/difference-between-binary-tree-and-binary-search-tree/)

[Top 50 Tree Coding Problems for Interviews](https://www.geeksforgeeks.org/top-50-tree-coding-problems-for-interviews/)
