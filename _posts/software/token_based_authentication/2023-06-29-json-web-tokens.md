---
layout: post
title:
description: ''
date: '2023-06-29'
categories: token_based_authentication
note:
mathjax:
mermaidJS: true
p5JS:
chartJS:
threeJS:
publish: true
---

## Introduction

quick explanation

## Why?

JWT (JSON Web Token) are used as a secure and compact means of transmitting and verifying claims or information between parties, enabling stateless authentication and authorization in distributed systems.

## How?

### Concept

<div class="mermaid">
  graph LR
    user(User) -- email, password --> sign_up_or_login_page[Sign Up or Login Page]
    sign_up_or_login_page[Landing Page] -- email, password --> jwt_service_create[JWT Creation Service]
    jwt_service_create[JWT Creation Service] -- JWT --> user(User)
    user(User) -- JWT --> secured_website(Secured Website)
    secured_website(Secured Website) -- JWT --> jwt_service_validate[JWT Validation Service]
    jwt_service_validate[JWT Validation Service] -- validate? --> secured_website(Secured Website)
    secured_website(Secured Website) -- validate? == yes --> show_page((Show Page))
    secured_website(Secured Website) -- validate? == no --> no_page((No Page))
</div>

In the context of the provided graph, JWT serves as a **secure token** that facilitates the **reliable exchange** of **user information** between two parties involved.
* User information: We called it **claims**; for example, the user's name, ID, roles, or any other relevant data.
* Secure token
  * Encoding: The JSON object with user information is encoded with **Base64Url**, resulting in a compact string that allows for easy transmission of the JWT across different systems without data loss.
  * Signature: To ensure integrity and **prevent tampering**, a signature is generated by calculating it over the encoded JWT using a shared secret key, and then appending it to the JWT separated by a period.
* Reliable Exchange: The JWT is commonly transmitted as a **Bearer Token** in the Authorization header of an HTTP request, prefixed with the word "Bearer" followed by a space, before the actual JWT.

### Pseudocode in Ruby

#### Use case

```ruby
secret_key = 'your-secret-key' # For signature, so that we can prevent any tampering from frontend
jwt_service = JWTService.new(secret_key)

payload = { user_id: 123, role: 'admin' } # Claims

# Encode and sign the JWT token
token = jwt_service.encode_jwt(payload) # Going to return this token to frontend

# Decode and verify the JWT token received from frontend
begin
  decoded_payload = jwt_service.decode_jwt(token)
  puts "Decoded Payload: #{decoded_payload}"
rescue StandardError => e
  puts "Invalid token: #{e.message}"
end
```

#### Service

```ruby
require 'base64'
require 'openssl'
require 'json'

class JWTService
  def initialize(secret_key)
    @secret_key = secret_key
  end

  def encode_jwt(payload)
    encoded_payload = base64_url_encode(payload.to_json)
    signature = sign_token(encoded_payload) # Depends on payload and secret key

    data + '.' + signature
  end

  def decode_jwt(token)
    parts = token.split('.')
    encoded_payload = parts[1]
    signature = parts[2]

    payload = JSON.parse(base64_url_decode(encoded_payload))

    data = parts[0] + '.' + encoded_payload
    calculated_signature = sign_token(data)

    if signature == calculated_signature
      payload
    else
      raise 'Invalid token: Signature mismatch'
    end
  end

  private

  def base64_url_encode(data)
    Base64.urlsafe_encode64(data).gsub('=', '')
  end

  def base64_url_decode(encoded_data)
    padding_length = 4 - (encoded_data.length % 4)
    encoded_data += '=' * padding_length

    Base64.urlsafe_decode64(encoded_data)
  end

  def sign_token(data)
    hmac = OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha256'), @secret_key, data)
    signature = base64_url_encode(hmac)
    signature
  end
end
```

## What

(TBC, 2023/07/09)

### Rails + Vue

#### Rails 

```ruby
class SessionsController < ApplicationController
  def create
    user = User.find_by(username: params[:username])

    if user && user.authenticate(params[:password])
      # Generate a JWT token
      token = JWT.encode(
        {
          user_id: user.id,
          # more claims
        },
        Rails.application.secrets.secret_key_base, # 
        'HS256'
      )

      render json: { token: token }
    else
      render json: { error: 'Invalid credentials' }, status: :unauthorized
    end
  end
end
```

#### Vue

```javascript
<template>
  <form @submit.prevent="handleLogin">
    <input type="text" v-model="username" placeholder="Username" />
    <input type="password" v-model="password" placeholder="Password" />
    <button type="submit">Login</button>
  </form>
</template>

<script>
import axios from 'axios';

export default {
  data() {
    return {
      username: '',
      password: '',
    };
  },
  methods: {
    async handleLogin() {
      try {
        const response = await axios.post('http://localhost:3000/login', {
          username: this.username,
          password: this.password,
        });

        const token = response.data.token;
        // Store the token in local storage or session storage for later use

        // Redirect the user to a protected route or perform other actions
      } catch (error) {
        console.error(error);
        // Handle login error
      }
    },
  },
};
</script>
```

## Reference
