<h2 id="introduction">Introduction</h2>

<p>Before we dive into the world, please understand the basic concepts in the mindset, basic-concept-related-to-DSA.md. The structure of this article is as follow:</p>

<ul>
  <li>data Structure: store data in a specific logic
    <ul>
      <li>hash table, arraylist, string_builder, vector</li>
      <li>linked list</li>
      <li>tree, tries, graph</li>
      <li>stack, queue</li>
      <li>heap</li>
    </ul>
  </li>
  <li>Algorithm: methods to achieve most important goal given specific data structure
    <ul>
      <li>breath-first search</li>
      <li>depth-first search</li>
      <li>binary search</li>
      <li>merge sort</li>
      <li>quick sort</li>
    </ul>
  </li>
  <li>key concepts:
    <ul>
      <li>bit Manipulation</li>
      <li>memory (stack vs. heap)</li>
      <li>recursion</li>
      <li>dynamic programming</li>
      <li>big O about time and space complexity</li>
    </ul>
  </li>
</ul>

<h2 id="why">Why</h2>

<p>To solve problem in a more efficient way, making no more space to improve both the time complexity and space complexity.</p>

<h2 id="how">How</h2>

<p>We can decompose all the programming logics into four actions:</p>

<ul>
  <li>create</li>
  <li>read</li>
  <li>update</li>
  <li>delete</li>
</ul>

<p>and the method to evaluate these actions’ performance are time complexity and space complexity.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">time complexity of</th>
      <th style="text-align: center">arraylist</th>
      <th style="text-align: right">…</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">create (insert)</td>
      <td style="text-align: center">O(n)</td>
      <td style="text-align: right">O(1)</td>
    </tr>
    <tr>
      <td style="text-align: left">read (access with id)</td>
      <td style="text-align: center">あなた</td>
      <td style="text-align: right">あなたたち</td>
    </tr>
    <tr>
      <td style="text-align: left">search (access with attributes)</td>
      <td style="text-align: center">かのじょ</td>
      <td style="text-align: right">かのじょたち</td>
    </tr>
    <tr>
      <td style="text-align: left">destroy (delete)</td>
      <td style="text-align: center">かのじょ</td>
      <td style="text-align: right">かのじょたち</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>create: O(1) to O(N)
    <ul>
      <li>inserting an element at the end of an array has \(O(1)\)</li>
      <li>inserting an element at the beginning of an array has \(O(N)\) because we need to shift all the elements</li>
      <li>inserting at given index is at most \(O(N)\) because it needs to shift all the elements behind it</li>
    </ul>
  </li>
  <li>linear search has \(O(N)\) because it needs to search the value from beginning</li>
  <li>search by index has \(O(1)\) because we can return the value with index such that list[id]</li>
  <li>update is not an issue because it just changes the value of an found data</li>
</ul>

<h2 id="what">What</h2>

<h3 id="arrays">arrays</h3>

<p>Arrays are a list of data “serially positioned”; for example,</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">]</span>
</code></pre></div></div>

<p>There are indexes in the array, so that the computer can easily find the elements with indexes; for example, the index of the element, <code class="language-plaintext highlighter-rouge">1</code> is <code class="language-plaintext highlighter-rouge">0</code>.</p>

<h4 id="create-in-array">create in array</h4>

<ol>
  <li>
    <p>time complexity = O(1)
Because of the indexing, we can easily insert the element to the specific position we want, so the time complexity is O(1).</p>
  </li>
  <li>
    <p>space complexity = O(n)
The space complexity is O(n) at most; for example, if we append element at the beginning of the array, we need to shift all elements at once.</p>
  </li>
</ol>

<h4 id="read-in-array">read in array</h4>

<ol>
  <li>
    <p>time complexity = O(1)
Because of indexing, we can find the element in an array without traversing any element, so the time complexity is O(1).</p>
  </li>
  <li>
    <p>no space complexity issue
Because we won’t move any address of the elements in array, there is no space complexity issue.</p>
  </li>
</ol>

<h4 id="update-in-array">Update in array</h4>

<p>skip</p>

<h4 id="delete-in-array">delete in array</h4>

<p>skip</p>

<h3 id="stacks">stacks</h3>

<h4 id="create-in-stack">create in stack</h4>

<p>The rule of stack is LIFO (last in first out). Given a stack,</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">]</span>
</code></pre></div></div>

<ol>
  <li>
    <p>time complexity</p>
  </li>
  <li>
    <p>space complexity</p>
    <h4 id="read-in-stack">read in stack</h4>
  </li>
</ol>

<h4 id="update-in-stack">update in stack</h4>

<h4 id="delete-in-stack">delete in stack</h4>

<h3 id="queues">queues</h3>

<h3 id="linked-list">linked list</h3>

<h3 id="trees">trees</h3>

<h3 id="graphs">graphs</h3>

<h3 id="tries">tries</h3>

<h3 id="hash-table">hash table</h3>

<h2 id="reference">reference</h2>

<p>cracking the coding interview</p>

<p><a href="https://www.freecodecamp.org/news/the-top-data-structures-you-should-know-for-your-next-coding-interview-36af0831f5e3/"><strong>The top data structures you should know for your next coding interview</strong></a></p>
