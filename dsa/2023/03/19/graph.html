<!DOCTYPE html>
<html lang="en-US">
  <head>
    

    

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
  const config = {
    theme: 'neutral',
    startOnLoad:true,
    htmlLabels:true,
  };
  mermaid.initialize(config);
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <link rel="stylesheet" href="/blog/assets/css/main.css">
    <script src="https://kit.fontawesome.com/f9271f6bdd.js" crossorigin="anonymous"></script>
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  </head>

  <body class="font-mono list-disc bg-gray-700">
    <div class="pt-8 bg-gray-700">
      
        <nav class="flex flex-wrap items-center justify-center px-2 py-4 mb-6">
  <div class="titleImagePosition">
    <a href="/blog/" class="!px-0 !py-0">
      <img class="titleImage" src="/blog/assets/img/title.jpeg" alt="author profile image">
    </a>
  </div>
  <div class="flex">
    <div class="container px-4 mx-auto flex flex-wrap items-center justify-center">
      <div class="absolute right-16 flex md:block" id="navbar">
        <div class="flex flex-col md:flex-row mr-auto w-full">
          <!-- dynamic menu based on navigation info in _config.yml -->
          
             <!-- don't show current page in menu -->
              <a class="text-sm text-gray-500 hover:text-gray-900 px-3 py-2 mx-auto uppercase"
                href="/blog/about">
                About Me
              </a>
            
          
        </div>
      </div>
    </div>
  </div>
</nav>

      
      
  <div id='sidebar' class='fixed py-16 hidden lg:block'></div>
  <div id='burger-sidebar' class='pt-24 pl-4 fixed hidden md:block'></div>

<div class='prose bg-gray-400' id='article'>
  <div id='word-count' class='pt-4 pl-8 fixed'>words: 80</div>
  <div class='text-center'>
    
  </div>
  <div class='md:px-4 md:grid lg:px-72'>
    <h1 class='text-center mt-6 mb-6'>Graph</h1>
    <h2 id="introduction">Introduction</h2>

<p>This article discusses the usefulness of graphs for visually representing relationships and connections between data points, as well as various applications of graph algorithms, including modeling real-world problems, analyzing software dependencies, and optimizing code. It also provides an overview of important graph terminology, such as vertices and edges, and presents code examples for implementing graph algorithms such as depth-first search and breadth-first search.</p>

<h2 id="why">Why?</h2>

<p>Graphs are valuable tools for visually representing the relationships and connections among data points, enabling us to easily discern patterns and gain insightful observations.</p>

<h2 id="how">How?</h2>

<h3 id="visualization">Visualization</h3>

<div class="mermaid">
flowchart TD
    id1((0)) --- id2((1))
    id4((3)) --- id2((1))
    id4((3)) --- id3((2))
    id1((0)) --- id4((3))
    id3((2)) --- id1((0))
    id2((1)) --- id2((1))
</div>

<h3 id="terminology">terminology</h3>

<ul>
  <li>Vertices
    <ul>
      <li>Concept: Represent the objects or entities being modeled</li>
      <li>Example: The nodes with naming, 1, 2, 3, 4</li>
    </ul>
  </li>
  <li>Edges
    <ul>
      <li>Concept: Edges represent the relationships or connections between those objects. Edges can be directed or undirected, and can have weights or costs associated with them to represent the strength or importance of the relationship between vertices</li>
      <li>Example: The lines connect the vertices</li>
    </ul>
  </li>
  <li>Representation
    <ul>
      <li>Represented using various data structures, such as adjacency matrices, adjacency lists, and edge lists</li>
      <li>Examples
        <ul>
          <li>Adjacency matrices
            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   | 0 | 1 | 2 | 3 |
<span class="nt">---------------------</span>
0  | 0 | 1 | 0 | 1 |
1  | 0 | 1 | 0 | 0 |
2  | 1 | 0 | 0 | 0 |
3  | 0 | 1 | 1 | 0 |
</code></pre></div>            </div>
            <ul>
              <li>The value 1 represents the presence of an edge between two vertices.</li>
            </ul>
          </li>
          <li>Adjacency lists (What I prefer, refer to <a href="https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38">here</a>)
            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: <span class="o">[</span>1, 4]
1: <span class="o">[</span>2]
2: <span class="o">[]</span>
3: <span class="o">[</span>1, 2]
</code></pre></div>            </div>
          </li>
          <li>Edge lists
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[(0, 1), (1, 2), (2, 0), (3, 1), (3, 2), (0, 4)]
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Other
    <ul>
      <li>Self loop: the edge from a vertex to itself</li>
    </ul>
  </li>
</ul>

<h3 id="basic-form">Basic Form</h3>

<p>Here will compose a class of adjacency lists</p>

<ul>
  <li>Basic structure (based on visualization)
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">// adjacency lists</span>
  <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
  <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
  <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
  <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </li>
  <li>Code example
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Graph</span> <span class="p">{</span>
  <span class="c1">// Adjacency list form</span>
  <span class="c1">// Undirected edges</span>
  <span class="c1">// No attributes on edges and nodes</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="p">}</span>

  <span class="c1">// create</span>
  <span class="nx">addVertex</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="p">}</span>
  
  <span class="nx">addEdge</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">,</span> <span class="nx">vertex2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex1</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">vertex2</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex2</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// read</span>
  <span class="nx">getNeighbors</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="nx">getVertices</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">getEdges</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">()</span> <span class="c1">// use set</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">vertexOne</span><span class="p">,</span> <span class="nx">vertexTwos</span><span class="p">]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">vertexTwos</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">vertexTwo</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">edges</span><span class="p">.</span><span class="nx">add</span><span class="p">([</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">vertexOne</span><span class="p">),</span> <span class="nx">vertexTwo</span><span class="p">])})</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">edges</span>
  <span class="p">}</span>

  <span class="nx">findVertex</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">findEdge</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">,</span> <span class="nx">vertex2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">).</span><span class="nx">has</span><span class="p">(</span><span class="nx">vertex2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">vertex2</span><span class="p">).</span><span class="nx">has</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// update</span>
  <span class="c1">// There will be no update methods for vertex and edge because in this class there is no attributes for both of them.</span>
  
  <span class="c1">// destroy</span>
  <span class="nx">removeEdge</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">,</span> <span class="nx">vertex2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">index2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex1</span><span class="p">].</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">vertex2</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">index1</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex2</span><span class="p">].</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">index2</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex1</span><span class="p">].</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">index1</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex2</span><span class="p">].</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">removeVertex</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex</span><span class="p">].</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">neighborVertex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">[</span><span class="nx">vertex</span><span class="p">].</span><span class="nx">pop</span><span class="p">();</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">removeEdge</span><span class="p">(</span><span class="nx">vertex</span><span class="p">,</span> <span class="nx">neighborVertex</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">Graph</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>spec
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Graph</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">../examples/graph.js</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">Graph</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">testGraph</span>
  <span class="nx">beforeEach</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">testGraph</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">();</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">node</span> <span class="o">=&gt;</span> <span class="nx">testGraph</span><span class="p">.</span><span class="nx">addVertex</span><span class="p">(</span><span class="nx">node</span><span class="p">));</span>
    <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">edge</span> <span class="o">=&gt;</span> <span class="nx">testGraph</span><span class="p">.</span><span class="nx">addEdge</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
  <span class="p">})</span>
  
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">#init</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">3</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([]);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">4</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
  <span class="p">})</span>
  
  <span class="c1">// create</span>
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">#addVertex</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">testGraph</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getVertices</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
  <span class="p">})</span>
  
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">#addEdge</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">newEdge</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="nx">testGraph</span><span class="p">.</span><span class="nx">addEdge</span><span class="p">(</span><span class="nx">newEdge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">newEdge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getEdges</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">(</span><span class="k">new</span> <span class="nb">Set</span><span class="p">([</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">]));</span>
  <span class="p">})</span>
  
  <span class="c1">// read</span>
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">#getNeighbors</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">3</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([])</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">4</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
  <span class="p">})</span>
  
  <span class="nx">test</span><span class="p">.</span><span class="nx">only</span><span class="p">(</span><span class="dl">'</span><span class="s1">#getVertices</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getVertices</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
  <span class="p">})</span>
  
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">#getEdges</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getEdges</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">(</span><span class="k">new</span> <span class="nb">Set</span><span class="p">([</span>
      <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">],</span>
      <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="p">],</span>
      <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="p">],</span>
      <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="p">],</span>
      <span class="p">[</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">],</span>
      <span class="p">[</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">]</span>
    <span class="p">]));</span>
  <span class="p">})</span>
  
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">#findVertex</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">findVertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">findVertex</span><span class="p">(</span><span class="mi">5</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
  <span class="p">})</span>
  
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">#findEdge</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">findEdge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">findEdge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">findEdge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
  <span class="p">})</span>
  
  <span class="c1">// update</span>
  
  <span class="c1">// destroy</span>
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">removeEdge</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">testGraph</span><span class="p">.</span><span class="nx">removeEdge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">4</span><span class="p">]);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">4</span><span class="p">]);</span>
  <span class="p">})</span>
  
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">removeVertex</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">testGraph</span><span class="p">.</span><span class="nx">removeVertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getVertices</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">getEdges</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">();</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div>    </div>
  </li>
  <li>Time complexity
    <ul>
      <li>Adding a vertex: O(1) (constant time)</li>
      <li>Adding an edge: O(1) (constant time)</li>
      <li>Removing a vertex: O(V + E) (linear time, where V is the number of vertices and E is the number of edges)</li>
      <li>Removing an edge: O(1) (constant time)</li>
      <li>Finding a vertex: O(V) (linear time)</li>
      <li>Finding an edge: O(E) (linear time)</li>
    </ul>
  </li>
</ul>

<h3 id="traversal-algorithm">Traversal Algorithm</h3>

<p>I am going to use following graph to build traversal algorithms</p>

<div class="mermaid">
flowchart LR
    a((A)) --- b((B))
    a((A)) --- c((C))
    b((B)) --- d((D))
    b((B)) --- e((E))
    c((C)) --- f((F))
    e((E)) --- f((F))
    g((G))
</div>

<h4 id="dfs-depth-first-search">DFS (depth first search)</h4>

<ul>
  <li>Application
    <ul>
      <li>Find paths between two vertices</li>
      <li>Detect cycles in a graph</li>
      <li>Determine whether a graph is bipartite</li>
    </ul>
  </li>
  <li>Solution:
    <ol>
      <li>Choose a starting vertex in the graph.</li>
      <li>Visit the starting vertex and mark it as visited.</li>
      <li>Choose an unvisited neighbor of the current vertex.</li>
      <li>Move to the chosen neighbor and repeat steps 2 and 3 recursively.</li>
      <li>If there are no unvisited neighbors, backtrack to the previous vertex and choose the next unvisited neighbor (if any).</li>
      <li>Repeat steps 2-5 until all vertices have been visited or the desired condition is met.</li>
    </ol>
  </li>
  <li>Example:
    <ul>
      <li>A -&gt; B -&gt; D – backtrack to B -&gt; E -&gt; F -&gt; C -&gt; G, so the result will be [A, B, D, E, F, C, G]</li>
      <li>Intuition: Have a look at this <a href="https://www.youtube.com/watch?v=7fujbpJ0LB4">video</a></li>
    </ul>
  </li>
  <li>Time complexity: O(V + E)</li>
  <li>Code Example:
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">GraphTraversal</span> <span class="kd">extends</span> <span class="nx">Graph</span> <span class="p">{</span>
  <span class="nx">depthFirstSearch</span><span class="p">(</span><span class="nx">vertex</span><span class="p">,</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">vertex</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="nx">vertex</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">neighbor</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">depthFirstSearch</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">visited</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">GraphTraversal</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>Spec:
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Graph</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">../examples/graph.js</span><span class="dl">'</span><span class="p">);</span>
  
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">Graph</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">beforeEach</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">testGraph</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">();</span>
    <span class="p">[</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">G</span><span class="dl">'</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">node</span> <span class="o">=&gt;</span> <span class="nx">testGraph</span><span class="p">.</span><span class="nx">addVertex</span><span class="p">(</span><span class="nx">node</span><span class="p">));</span>
    <span class="p">[[</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span><span class="p">]].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">edge</span> <span class="o">=&gt;</span> <span class="nx">testGraph</span><span class="p">.</span><span class="nx">addEdge</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
  <span class="p">})</span>
  
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">DFS</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">depthFirstSearch</span><span class="p">(</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">([</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">G</span><span class="dl">'</span><span class="p">]);</span>
  <span class="p">})</span>
  <span class="p">...</span>
<span class="p">})</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="bfs-breath-first-search">BFS (breath first search)</h4>

<ul>
  <li>Application:
    <ul>
      <li>Find the shortest path between two nodes in an unweighted graph</li>
      <li>Find all the nodes that are at a certain distance from a given node</li>
      <li>Check for the existence of a path between two nodes in a graph</li>
    </ul>
  </li>
  <li>Solution:
    <ol>
      <li>Choose a starting vertex in the graph.</li>
      <li>Enqueue the starting vertex into a queue and mark it as visited.</li>
      <li>While the queue is not empty, perform the following steps:
  a. Dequeue a vertex from the front of the queue.
  b. Visit the dequeued vertex.</li>
      <li>For each unvisited neighbor of the visited vertex, do the following:
  a. Enqueue the neighbor into the queue.
  b. Mark the neighbor as visited.</li>
      <li>Repeat steps 3 and 4 until the queue becomes empty.</li>
    </ol>
  </li>
  <li>Example:
    <ul>
      <li>Start —- queue: [A] —-&gt; A —- Enqueue B and C (queue: [B, C]) —-&gt; B —- Enqueue D and E (queue: [C, D, E]) —-&gt; C —- Enqueue F (queue: [D, E, F]) —-&gt; D -&gt; E -&gt; F -&gt; G, so the result will be [A, B, C, D, E, F, G]</li>
      <li>Intuition: Have a look at this <a href="https://www.youtube.com/watch?v=oDqjPvD54Ss&amp;t=85s">video</a></li>
    </ul>
  </li>
  <li>Time complexity: O(V + E)
    <ul>
      <li>Given the result in example section, we can see that it will enqueue all nodes to visited array once and enqueue all nodes with edges to other nodes and not visited once, making the complexity to be V + E</li>
    </ul>
  </li>
  <li>code example
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">GraphTraversal</span> <span class="kd">extends</span> <span class="nx">Graph</span> <span class="p">{</span>
  <span class="nx">breadthFirstSearch</span><span class="p">(</span><span class="nx">startingVertex</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">startingVertex</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="nx">startingVertex</span><span class="p">]);</span>
  
    <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">currentVertex</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
      <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getNeighbors</span><span class="p">(</span><span class="nx">currentVertex</span><span class="p">);</span>
    
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">neighbors</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">);</span>
          <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
      
    <span class="k">return</span> <span class="nx">visited</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="p">...</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">GraphTraversal</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>spec
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Graph</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">../examples/graph.js</span><span class="dl">'</span><span class="p">);</span>
  
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">Graph</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">beforeEach</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">testGraph</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">();</span>
    <span class="p">[</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">G</span><span class="dl">'</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">node</span> <span class="o">=&gt;</span> <span class="nx">testGraph</span><span class="p">.</span><span class="nx">addVertex</span><span class="p">(</span><span class="nx">node</span><span class="p">));</span>
    <span class="p">[[</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span><span class="p">]].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">edge</span> <span class="o">=&gt;</span> <span class="nx">testGraph</span><span class="p">.</span><span class="nx">addEdge</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
  <span class="p">})</span>
  
  <span class="p">...</span>
  
  <span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">BFS</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">testGraph</span><span class="p">.</span><span class="nx">breadthFirstSearch</span><span class="p">(</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span><span class="p">]));</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="dfs-vs-bfs">DFS vs BFS</h4>

<ul>
  <li>Memory efficiency: DFS &gt; BFS because DFS do not need to another queue to store nodes going to visit.</li>
  <li>Detecting cycles: DFS &gt; BFS because DFS will go deeper first, which if there is cycle in a graph, it will return to a visited node on a route first, compared to BFS.</li>
  <li>Find shortest path: DFS &lt; BFS because BFS does level-by-level exploration. When we find a target nodes, we can stop the exploration and return the path from a node to target node.</li>
</ul>

<h3 id="route-between-nodes">Route Between Nodes</h3>

<p>TBC</p>

<h3 id="build-order">Build Order</h3>

<p>TBC</p>

<h3 id="dijkstras-algorithm">Dijkstra’s algorithm</h3>

<p>TBC</p>

<h2 id="what">What?</h2>

<h3 id="maze">Maze</h3>

<ul>
  <li>Try to find the shortest path in maze with DFS</li>
  <li>Represent maze as a graph, each cell is a node and the neighboring cells are connected by edges</li>
  <li>Use a depth-first search algorithm to explore all possible paths from the starting cell to the exit cell. We can mark each cell as visited as we explore the maze and keep track of the shortest path we’ve found so far. Once we reach the exit cell, we compare the length of the path we’ve found to the shortest path so far and update it if the new path is shorter.</li>
  <li>This approach can be optimized using techniques such as backtracking and memoization to avoid exploring paths that cannot lead to the shortest path.</li>
  <li>Code example:</li>
</ul>

<h2 id="todo">TODO</h2>

<ul>
  <li>Algorithms
    <ul>
      <li>shortest path algorithms
        <ul>
          <li>Dijkstra’s algorithm</li>
          <li>Bellman-Ford algorithm</li>
        </ul>
      </li>
      <li>minimum spanning tree algorithms
        <ul>
          <li>Prim’s algorithm</li>
          <li>Kruskal’s algorithm</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Graph traversal
    <ul>
      <li>shortest path between two nodes</li>
      <li>detecting cycles in a graph</li>
    </ul>
  </li>
</ul>

<h2 id="reference">Reference</h2>

<p><a href="https://www.tutorialspoint.com/Graph-Data-Structure-in-Javascript#:~:text=A%20graph%20is%20a%20pictorial,the%20vertices%20are%20called%20edges.">Graph Data Structure in Javascript</a></p>

<p><a href="https://towardsdatascience.com/10-graph-algorithms-visually-explained-e57faa1336f3">10 Graph Algorithms Visually Explained</a></p>

  </div>
</div>

<footer class="relative px-4 pt-4 pb-4">
    <!-- footer msg -->
  <div class="flex flex-wrap items-center justify-center">
    <br>
  </div>
</footer>

      <button
        type="button"
        data-mdb-ripple="true"
        data-mdb-ripple-color="light"
        class="scrollTopBtn"
        id="btn-back-to-top"
      >
        <svg aria-hidden="true" focusable="false" data-prefix="fas" class="w-4 h-4" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"></path></svg>
      </button>
    </div>
  </body>

  <script>
    /* Function for getting the current year in the footer */
    (function () {
      if (document.getElementById("get-current-year")) {
        document.getElementById(
          "get-current-year"
        ).innerHTML = new Date().getFullYear();
      }
    })();
    /* Function for opening navbar on mobile */
    function toggleNavbar(collapseID) {
        document.getElementById(collapseID).classList.toggle("hidden");
        document.getElementById(collapseID).classList.toggle("block");
      }
    /* Function for dropdowns */
    function openDropdown(event, dropdownID) {
      let element = event.target;
      while (element.nodeName !== "A") {
        element = element.parentNode;
      }
      document.getElementById(dropdownID).classList.toggle("hidden");
      document.getElementById(dropdownID).classList.toggle("block");
    }

    // Get the button
    let myButton = document.getElementById("btn-back-to-top");
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function () {
      scrollFunction();
    };
    function scrollFunction() {
      if (
        document.body.scrollTop > 20 ||
        document.documentElement.scrollTop > 20
      ) {
        myButton.style.display = "block";
      } else {
        myButton.style.display = "none";
      }
    }
    // When the user clicks on the button, scroll to the top of the document
    myButton.addEventListener("click", backToTop);
    function backToTop() {
      document.body.scrollTop = 0;
      document.documentElement.scrollTop = 0;
    }
  </script>

  <script type="text/javascript" src="/blog/assets/javascript/bundle.js" charset="utf-8"></script>
</html>
